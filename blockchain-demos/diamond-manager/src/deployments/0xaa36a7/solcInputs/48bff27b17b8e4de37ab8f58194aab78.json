{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     */\n    function royaltyInfo(\n        uint256 tokenId,\n        uint256 salePrice\n    ) external view returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "@openzeppelin/contracts/token/common/ERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/common/ERC2981.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC2981} from \"../../interfaces/IERC2981.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\n *\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\n *\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\n * fee is specified in basis points by default.\n *\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\n */\nabstract contract ERC2981 is IERC2981, ERC165 {\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n\n    RoyaltyInfo private _defaultRoyaltyInfo;\n    mapping(uint256 tokenId => RoyaltyInfo) private _tokenRoyaltyInfo;\n\n    /**\n     * @dev The default royalty set is invalid (eg. (numerator / denominator) >= 1).\n     */\n    error ERC2981InvalidDefaultRoyalty(uint256 numerator, uint256 denominator);\n\n    /**\n     * @dev The default royalty receiver is invalid.\n     */\n    error ERC2981InvalidDefaultRoyaltyReceiver(address receiver);\n\n    /**\n     * @dev The royalty set for an specific `tokenId` is invalid (eg. (numerator / denominator) >= 1).\n     */\n    error ERC2981InvalidTokenRoyalty(uint256 tokenId, uint256 numerator, uint256 denominator);\n\n    /**\n     * @dev The royalty receiver for `tokenId` is invalid.\n     */\n    error ERC2981InvalidTokenRoyaltyReceiver(uint256 tokenId, address receiver);\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc IERC2981\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual returns (address, uint256) {\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[tokenId];\n\n        if (royalty.receiver == address(0)) {\n            royalty = _defaultRoyaltyInfo;\n        }\n\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();\n\n        return (royalty.receiver, royaltyAmount);\n    }\n\n    /**\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\n     * override.\n     */\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n\n    /**\n     * @dev Sets the royalty information that all ids in this contract will default to.\n     *\n     * Requirements:\n     *\n     * - `receiver` cannot be the zero address.\n     * - `feeNumerator` cannot be greater than the fee denominator.\n     */\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            // Royalty fee will exceed the sale price\n            revert ERC2981InvalidDefaultRoyalty(feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidDefaultRoyaltyReceiver(address(0));\n        }\n\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    /**\n     * @dev Removes default royalty information.\n     */\n    function _deleteDefaultRoyalty() internal virtual {\n        delete _defaultRoyaltyInfo;\n    }\n\n    /**\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\n     *\n     * Requirements:\n     *\n     * - `receiver` cannot be the zero address.\n     * - `feeNumerator` cannot be greater than the fee denominator.\n     */\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\n        uint256 denominator = _feeDenominator();\n        if (feeNumerator > denominator) {\n            // Royalty fee will exceed the sale price\n            revert ERC2981InvalidTokenRoyalty(tokenId, feeNumerator, denominator);\n        }\n        if (receiver == address(0)) {\n            revert ERC2981InvalidTokenRoyaltyReceiver(tokenId, address(0));\n        }\n\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    /**\n     * @dev Resets royalty information for the token id back to the global default.\n     */\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        delete _tokenRoyaltyInfo[tokenId];\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"../ERC20.sol\";\nimport {Context} from \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys a `value` amount of tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 value) public virtual {\n        _burn(_msgSender(), value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, deducting from\n     * the caller's allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `value`.\n     */\n    function burnFrom(address account, uint256 value) public virtual {\n        _spendAllowance(account, _msgSender(), value);\n        _burn(account, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/common/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nstruct RoleData {\n\tmapping(address => bool) members;\n\tbytes32 adminRole;\n}\n \n/// @title  A contract that administrate roles & access\n/// @notice You can use this contract to modify and define the role of an user\nabstract contract AccessControlEnumerable is Context {\t\n    /// @notice This event stores in the blockchain when an admin role changes\n    /// @param  role Contains the admin role that we want to use \n    /// @param  previousAdminRole Contains the previous admin role\n    /// @param  newAdminRole Contains the new admin role\n\tevent RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\t/// @notice This event stores in the blockchain when a role is granted\n    /// @param  role Contains the admin role that we want to use \n    /// @param  account Contains the account we want to add to a new role\n    /// @param  sender Contains the sender of the role petition\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    /// @notice This event stores in the blockchain when a role is revoked\n    /// @param  role Contains the admin role that we want to use \n    /// @param  account Contains the account we want to add to a new role\n    /// @param  sender Contains the sender of the role petition\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /// @notice Allow an user to quit an owned role\n    /// @notice The account that sends the petition needs to be the same that will renounce to a role\n    /// @param  role Contains the role that we want to use \n    /// @param  account Contains the account address to use.    \n    function renounceRole(bytes32 role, address account) public {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n        _revokeRole(role, account);\n    }\n\n    /// @notice Allow an admin to asign a new role to an account\n    /// @param  role Contains the role that we want to use \n    /// @param  account Contains the account address to use. \n    function grantRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /// @notice Allow an admin to revoke a role to an account\n    /// @param  role Contains the role that we want to use \n    /// @param  account Contains the account address to use. \n    function revokeRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /// @notice Allow to verify if the account has a role\n    /// @param  role Contains the role that we want to use \n    /// @param  account Contains the account address to use. \n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /// @notice Allow to verify if the account has a role\n    /// @param  role Contains the role that we want to verify \n    /// @param  account Contains the account address to check. \n    /// @return role in boolean, if the account has the selected role\n    function hasRole(bytes32 role, address account) public view virtual returns (bool);\n\n\t/// @notice Allow us to verify the branch of roles asociated to an father role\n    /// @param  role Contains the role that we want to verify\n    /// @return bytes32 with the child role\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32);\n\n    /// @notice Check if the account with the index has the desired role\n    /// @param  role Contains the role that we want to use \n    /// @param  index Contains the index asociated to an account\n    /// @return address of the account with the index position in the list of the desired role\n\tfunction getRoleMember(bytes32 role, uint256 index) public view virtual returns (address);\n\n    /// @notice Allow to verify if the account has a role\n    /// @param  role Contains the role that we want to verify\n    /// @return uint256 wuth he total of members with the desired role \n\tfunction getRoleMemberCount(bytes32 role) public view virtual returns (uint256);\n\n    /// @param role Contains the role that we want to use \n    /// @param adminRole Contains the new admin role to use\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual;\n\n    /// @notice Grants a role to an account\n    /// @param  role Contains the role that we want to use \n    /// @param  account Contains the account address to use. \n\tfunction _grantRole(bytes32 role, address account) internal virtual;\n\n    /// @notice Revokes a role to an account \n    /// @param  role Contains the role that we want to use \n    /// @param  account Contains the account address to use. \n\tfunction _revokeRole(bytes32 role, address account) internal virtual;\n}"
    },
    "contracts/common/DiamondStorage/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport { Context } from \"@openzeppelin/contracts/utils/Context.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { AccessControlEnumerableStorage } from \"./AccessControlEnumerableStorage.sol\";\n\nabstract contract AccessControlEnumerable is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    \n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\tevent RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    function renounceRole(bytes32 role, address account) public {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n        _revokeRole(role, account);\n    }\n\n    function grantRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    function revokeRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n\tfunction hasRole(bytes32 role, address account) public view returns (bool) {\n\t\treturn AccessControlEnumerableStorage.layout()._roles[role].members[account];\n\t}\n\n\tfunction getRoleAdmin(bytes32 role) public view returns (bytes32) {\n\t\treturn AccessControlEnumerableStorage.layout()._roles[role].adminRole;\n\t}\n\n\tfunction getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n\t\treturn AccessControlEnumerableStorage.layout()._roleMembers[role].at(index);\n\t}\n\t\n\tfunction getRoleMemberCount(bytes32 role) public view returns (uint256) {\n\t\treturn AccessControlEnumerableStorage.layout()._roleMembers[role].length();\n\t}\n\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n\t\tbytes32 previousAdminRole = getRoleAdmin(role);\n\t\tAccessControlEnumerableStorage.layout()._roles[role].adminRole = adminRole;\n\t\temit RoleAdminChanged(role, previousAdminRole, adminRole);\n\t}\n\n\tfunction _grantRole(bytes32 role, address account) internal {\n\t\tif (!hasRole(role, account)) {\n\t\t\tAccessControlEnumerableStorage.layout()._roles[role].members[account] = true;\n\t\t\temit RoleGranted(role, account, _msgSender());\n\t\t\tAccessControlEnumerableStorage.layout()._roleMembers[role].add(account);\n\t\t}\n\t}\n\n\tfunction _revokeRole(bytes32 role, address account) internal {\n\t\tif (hasRole(role, account)) {\n\t\t\tAccessControlEnumerableStorage.layout()._roles[role].members[account] = false;\n\t\t\temit RoleRevoked(role, account, _msgSender());\n\t\t\tAccessControlEnumerableStorage.layout()._roleMembers[role].remove(account);\n\t\t}\n\t}\n}"
    },
    "contracts/common/DiamondStorage/AccessControlEnumerableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nlibrary AccessControlEnumerableStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('rair.contracts.storage.AccessControlEnumerable');\n\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    struct Layout {\n        mapping(bytes32 => RoleData) _roles;\n        mapping(bytes32 => EnumerableSet.AddressSet) _roleMembers;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}"
    },
    "contracts/diamondStandard/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport { LibDiamond } from \"./libraries/LibDiamond.sol\";\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\n\ncontract Diamond {    \n\n    constructor(address _contractOwner, address _diamondCutFacet) payable {        \n        LibDiamond.setContractOwner(_contractOwner);\n\n        // Add the diamondCut external function from the diamondCutFacet\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = IDiamondCut.FacetCut({\n            facetAddress: _diamondCutFacet, \n            action: IDiamondCut.FacetCutAction.Add, \n            functionSelectors: functionSelectors\n        });\n        LibDiamond.diamondCut(cut, address(0), \"\");        \n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        assembly {\n            ds.slot := position\n        }\n        // get facet from function selector\n        address facet = address(bytes20(ds.facets[msg.sig]));\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/diamondStandard/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\ncontract DiamondCutFacet is IDiamondCut {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            (selectorCount, selectorSlot) = LibDiamond.addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        LibDiamond.initializeDiamondCut(_init, _calldata);\n    }\n}\n"
    },
    "contracts/diamondStandard/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport { LibDiamond } from  \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\n\n// The functions in DiamondLoupeFacet MUST be added to a diamond.\n// The EIP-2535 Diamond standard requires these functions\n\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n    // Diamond Loupe Functions\n    ////////////////////////////////////////////////////////////////////\n    /// These functions are expected to be called frequently by tools.\n    //\n    // struct Facet {\n    //     address facetAddress;\n    //     bytes4[] functionSelectors;\n    // }\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets() external override view returns (Facet[] memory facets_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facets_ = new Facet[](ds.selectorCount);\n        uint16[] memory numFacetSelectors = new uint16[](ds.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\n                bool continueLoop;\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facets_[facetIndex].facetAddress == facetAddress_) {\n                        facets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;\n                        // probably will never have more than 256 functions from one facet contract\n                        require(numFacetSelectors[facetIndex] < 255);\n                        numFacetSelectors[facetIndex]++;\n                        continueLoop = true;\n                        break;\n                    }\n                }\n                if (continueLoop) {\n                    continue;\n                }\n                facets_[numFacets].facetAddress = facetAddress_;\n                facets_[numFacets].functionSelectors = new bytes4[](ds.selectorCount);\n                facets_[numFacets].functionSelectors[0] = selector;\n                numFacetSelectors[numFacets] = 1;\n                numFacets++;\n            }\n        }\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n            uint256 numSelectors = numFacetSelectors[facetIndex];\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\n            // setting the number of selectors\n            assembly {\n                mstore(selectors, numSelectors)\n            }\n        }\n        // setting the number of facets\n        assembly {\n            mstore(facets_, numFacets)\n        }\n    }\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\n    function facetFunctionSelectors(address _facet) external override view returns (bytes4[] memory _facetFunctionSelectors) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 numSelectors;\n        _facetFunctionSelectors = new bytes4[](ds.selectorCount);\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(ds.facets[selector]));\n                if (_facet == facet) {\n                    _facetFunctionSelectors[numSelectors] = selector;\n                    numSelectors++;\n                }\n            }\n        }\n        // Set the number of selectors in the array\n        assembly {\n            mstore(_facetFunctionSelectors, numSelectors)\n        }\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external override view returns (address[] memory facetAddresses_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddresses_ = new address[](ds.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\n                bool continueLoop;\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facetAddress_ == facetAddresses_[facetIndex]) {\n                        continueLoop = true;\n                        break;\n                    }\n                }\n                if (continueLoop) {                    \n                    continue;\n                }\n                facetAddresses_[numFacets] = facetAddress_;\n                numFacets++;\n            }\n        }\n        // Set the number of facet addresses in the array\n        assembly {\n            mstore(facetAddresses_, numFacets)\n        }\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external override view returns (address facetAddress_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddress_ = address(bytes20(ds.facets[_functionSelector]));\n    }\n\n    // This implements ERC-165.\n    function supportsInterface(bytes4 _interfaceId) external override view returns (bool) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }\n}\n"
    },
    "contracts/diamondStandard/facets/OwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\n\ncontract OwnershipFacet is IERC173 {\n    function transferOwnership(address _newOwner) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.setContractOwner(_newOwner);\n    }\n\n    function owner() external override view returns (address owner_) {\n        owner_ = LibDiamond.contractOwner();\n    }\n}\n"
    },
    "contracts/diamondStandard/facets/Test1Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Test1Facet {\n    event TestEvent(address something);\n\n    function test1Func1() external {}\n\n    function test1Func2() external {}\n\n    function test1Func3() external {}\n\n    function test1Func4() external {}\n\n    function test1Func5() external {}\n\n    function test1Func6() external {}\n\n    function test1Func7() external {}\n\n    function test1Func8() external {}\n\n    function test1Func9() external {}\n\n    function test1Func10() external {}\n\n    function test1Func11() external {}\n\n    function test1Func12() external {}\n\n    function test1Func13() external {}\n\n    function test1Func14() external {}\n\n    function test1Func15() external {}\n\n    function test1Func16() external {}\n\n    function test1Func17() external {}\n\n    function test1Func18() external {}\n\n    function test1Func19() external {}\n\n    function test1Func20() external {}\n\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {}\n}\n"
    },
    "contracts/diamondStandard/facets/Test2Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Test2Facet {\n    function test2Func1() external {}\n\n    function test2Func2() external {}\n\n    function test2Func3() external {}\n\n    function test2Func4() external {}\n\n    function test2Func5() external {}\n\n    function test2Func6() external {}\n\n    function test2Func7() external {}\n\n    function test2Func8() external {}\n\n    function test2Func9() external {}\n\n    function test2Func10() external {}\n\n    function test2Func11() external {}\n\n    function test2Func12() external {}\n\n    function test2Func13() external {}\n\n    function test2Func14() external {}\n\n    function test2Func15() external {}\n\n    function test2Func16() external {}\n\n    function test2Func17() external {}\n\n    function test2Func18() external {}\n\n    function test2Func19() external {}\n\n    function test2Func20() external {}\n}\n"
    },
    "contracts/diamondStandard/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/diamondStandard/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/diamondStandard/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/diamondStandard/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/diamondStandard/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct DiamondStorage {\n        // maps function selectors to the facets that execute the functions.\n        // and maps the selectors to their position in the selectorSlots array.\n        // func selector => address facet, selector position\n        mapping(bytes4 => bytes32) facets;\n        // array of slots of function selectors.\n        // each slot holds 8 function selectors.\n        mapping(uint256 => bytes32) selectorSlots;\n        // The number of function selectors in selectorSlots\n        uint16 selectorCount;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    // Internal function version of diamondCut\n    // This code is almost the same as the external diamondCut,\n    // except it is using 'Facet[] memory _diamondCut' instead of\n    // 'Facet[] calldata _diamondCut'.\n    // The code is duplicated to prevent copying calldata to memory which\n    // causes an error for a two dimensional array.\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        DiamondStorage storage ds = diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addReplaceRemoveFacetSelectors(\n        uint256 _selectorCount,\n        bytes32 _selectorSlot,\n        address _newFacetAddress,\n        IDiamondCut.FacetCutAction _action,\n        bytes4[] memory _selectors\n    ) internal returns (uint256, bytes32) {\n        DiamondStorage storage ds = diamondStorage();\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        if (_action == IDiamondCut.FacetCutAction.Add) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                require(address(bytes20(oldFacet)) == address(0), \"LibDiamondCut: Can't add function that already exists\");\n                // add facet for selector\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\n                // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\n                // clear selector position in slot and add selector\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    // \"_selectorSlot >> 3\" is a gas efficient division by 8 \"_selectorSlot / 8\"\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\n                    _selectorSlot = 0;\n                }\n                _selectorCount++;\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n                // only useful if immutable functions exist\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\n                require(oldFacetAddress != _newFacetAddress, \"LibDiamondCut: Can't replace function with same function\");\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\n                // replace old facet address\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n            // \"_selectorCount >> 3\" is a gas efficient division by 8 \"_selectorCount / 8\"\n            uint256 selectorSlotCount = _selectorCount >> 3;\n            // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \n            uint256 selectorInSlotIndex = _selectorCount & 7;\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\n                if (_selectorSlot == 0) {\n                    // get last selectorSlot\n                    selectorSlotCount--;\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n                // adding a block here prevents stack too deep error\n                {\n                    bytes4 selector = _selectors[selectorIndex];\n                    bytes32 oldFacet = ds.facets[selector];\n                    require(address(bytes20(oldFacet)) != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n                    // only useful if immutable functions exist\n                    require(address(bytes20(oldFacet)) != address(this), \"LibDiamondCut: Can't remove immutable function\");\n                    // replace selector with last selector in ds.facets\n                    // gets the last selector\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\n                    }\n                    delete ds.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    // \"oldSelectorCount >> 3\" is a gas efficient division by 8 \"oldSelectorCount / 8\"\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    // \"oldSelectorCount & 7\" is a gas efficient modulo by eight \"oldSelectorCount % 8\" \n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                    // update storage with the modified slot\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    _selectorSlot =\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n                if (selectorInSlotIndex == 0) {\n                    delete ds.selectorSlots[selectorSlotCount];\n                    _selectorSlot = 0;\n                }\n            }\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\n        } else {\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n        }\n        return (_selectorCount, _selectorSlot);\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");        \n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/diamondStandard/upgradeInitializers/DiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\n\n// It is expected that this contract is customized if you want to deploy your diamond\n// with data from a deployment script. Use the init function to initialize state variables\n// of your diamond. Add parameters to the init funciton if you need to.\n\ncontract DiamondInit {    \n\n    // You can add parameters to this function in order to pass in \n    // data to set your own state variables\n    function init() external {\n        // adding ERC165 data\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n\n        // add your own state variables \n        // EIP-2535 specifies that the `diamondCut` function takes two optional \n        // arguments: address _init and bytes calldata _calldata\n        // These arguments are used to execute an arbitrary function using delegatecall\n        // in order to set state variables in the diamond during deployment or an upgrade\n        // More info here: https://eips.ethereum.org/EIPS/eip-2535#diamond-interface \n    }\n\n\n}\n"
    },
    "contracts/Factory/AccessControlRoles.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\nabstract contract FactoryHandlerRoles {\n\tbytes32 public constant WITHDRAW_SIGNER = keccak256(\"rair.factory.withdrawSystemSigner\");\n\tbytes32 public constant ADMINISTRATOR = keccak256(\"rair.factory.administrator\");\n\tbytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n}"
    },
    "contracts/Factory/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nlibrary FactoryStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('rair.contracts.storage.DiamondFactory');\n\n    struct Layout {\n        address[] creators;\n\t\tmapping(address => address[]) creatorToContracts;\n\t\tmapping(address => address) contractToCreator;\n\t\tmapping(address => uint) deploymentCostForToken;\n        address currentERC20;\n        mapping(address => uint) currentUserPoints;\n        mapping(address => uint) totalUserPoints;\n        uint transferTimeLimit;\n        address facetSource;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}"
    },
    "contracts/Factory/facets/creatorsFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\nimport { AccessControlEnumerable } from \"../../common/DiamondStorage/AccessControlEnumerable.sol\";\nimport { FactoryStorage } from \"../AppStorage.sol\";\n\n/// @title \tOur Facet creators contract\n/// @notice You can use this contract to view the creator of contracts and the list of contractsdeployed\ncontract CreatorsFacet is AccessControlEnumerable {\n\t/// @notice Returns the number of addresses that have deployed a contract\n\t/// @return count with the total of creators of this contract\n\tfunction getCreatorsCount() public view returns(uint count) {\n\t\treturn FactoryStorage.layout().creators.length;\n\t}\n\n\t/// @notice Returns a single address inside the creators array\n\t/// @param \tindex number of the index for look inside our array\n\t/// @return creator \tAddress of the selected index\n\tfunction getCreatorAtIndex(uint index) public view returns (address creator) {\n\t\tcreator = FactoryStorage.layout().creators[index];\n\t}\n\n\t/// @notice Returns the number of contracts deployed by an address\n\t/// @dev\tUse alongside creatorToContracts for the full list of tokens \n\t/// @param\tdeployer\tWallet address to query\n\t/// @return count \tNumber of contracts deployed by the deployer\n\tfunction getContractCountOf(address deployer) public view returns(uint count) {\n\t\treturn FactoryStorage.layout().creatorToContracts[deployer].length;\n\t}\n\n\t/// @notice Necessary view function now that public mappings are not possible\n\t/// @param \tdeployer Contains the facet addresses and function selectors\n\t/// @param \tindex Contains the facet addresses and function selectors\n\t/// @return deployedContract \tAddress of the deployed ERC721\n\tfunction creatorToContractIndex(address deployer, uint index) public view returns(address deployedContract) {\n\t\treturn FactoryStorage.layout().creatorToContracts[deployer][index];\n\t}\n\n\t/// @notice Returns the whole array of deployed addresses of a creator\n\t/// @param \tdeployer Contains the facet addresses and function selectors\n\t/// @return deployedContracts \tAddresses of the deployed contracts  \n\tfunction creatorToContractList(address deployer) public view returns(address[] memory deployedContracts) {\n\t\treturn FactoryStorage.layout().creatorToContracts[deployer];\n\t}\n\n\t/// @notice Returns the address of the creator given a deployed contract's address\n\t/// @param \tdeployedContract Contains the facet addresses and function selectors\n\t/// @return creator \tAddress of the contracts creator\n\tfunction contractToCreator(address deployedContract) public view returns (address creator) {\n\t\tcreator = FactoryStorage.layout().contractToCreator[deployedContract];\n\t}\n\n\t/// @notice Returns the address of the creator given a deployed contract's address\n\t/// @param \tfacetSource \tContains the facet addresses and function selectors\n\tfunction setFacetSource(address facetSource) public {\n\t\tFactoryStorage.Layout storage store = FactoryStorage.layout();\n\t\tstore.facetSource = facetSource;\n\t}\n\n\tfunction getFacetSource() public view returns (address facetSource) {\n\t\tfacetSource = FactoryStorage.layout().facetSource;\n\t}\n}"
    },
    "contracts/Factory/facets/DeployerFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { AccessControlEnumerable } from \"../../common/DiamondStorage/AccessControlEnumerable.sol\";\nimport { RAIR721_Diamond } from \"../../tokens/RAIR-721/RAIR-ERC721.sol\";\nimport { FactoryStorage } from \"../AppStorage.sol\";\n\n/// @title \tERC721 factory\n/// @notice\tFacet receives ERC777 tokens and deploys an ERC721 smart contract\ncontract DeployerFacet is AccessControlEnumerable {\n\t/// @notice This event stores in the blockchain when a new contract is deployed\n    /// @param\tdeployerAddress \tContains the address of the deployer of the contract \n    /// @param \tdeploymentIndex \tContains the corresponding ID for the deployment\n    /// @param \tdeploymentAddress \tContains the address where the contract was deployed\n\t/// @param \tdeploymentName \t\tContains the name of the deployed contract\n\tevent DeployedContract(\n\t\taddress deployerAddress,\n\t\tuint deploymentIndex,\n\t\taddress deploymentAddress,\n\t\tstring deploymentName\n\t);\n\n\tfunction deployContract(\n\t\tstring calldata contractName,\n\t\tstring calldata contractSymbol\n\t) external {\n\t\tFactoryStorage.Layout storage store = FactoryStorage.layout();\n\t\trequire(\n\t\t\tIERC20(store.currentERC20).allowance(msg.sender, address(this)) >= store.deploymentCostForToken[store.currentERC20],\n\t\t\t'Deployer: Not allowed to transfer tokens'\n\t\t);\n\t\trequire(\n\t\t\tIERC20(store.currentERC20).transferFrom(msg.sender, address(this), store.deploymentCostForToken[store.currentERC20]),\n\t\t\t'Deployer: Error transferring tokens'\n\t\t);\n\n\t\taddress[] storage deploymentsFromOwner = store.creatorToContracts[msg.sender];\n\t\tstore.totalUserPoints[msg.sender] += store.deploymentCostForToken[store.currentERC20];\n\t\t\n\t\tif (deploymentsFromOwner.length == 0) {\n\t\t\tstore.creators.push(msg.sender);\n\t\t}\n\n\t\tRAIR721_Diamond newToken = new RAIR721_Diamond(contractName, contractSymbol, msg.sender, 30000);\n\t\tdeploymentsFromOwner.push(address(newToken));\n\t\tstore.contractToCreator[address(newToken)] = msg.sender;\n\t\temit DeployedContract(msg.sender, deploymentsFromOwner.length - 1, address(newToken), contractName);\n\t}\n}"
    },
    "contracts/Factory/facets/DepositLogic.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { AccessControlEnumerable } from '../../common/DiamondStorage/AccessControlEnumerable.sol';\nimport { FactoryHandlerRoles } from '../AccessControlRoles.sol';\nimport { FactoryStorage } from \"../AppStorage.sol\";\n\n/// @title \tDeposit logic for the points system\n/// @notice Uses the ERC777 receiver hook to trigger additional logic\ncontract PointsDeposit is AccessControlEnumerable, FactoryHandlerRoles {\n    /// @notice This event stores the user that deposited tokens into the contract\n    /// @param\tuserAddress             Public address of the user depositing\n    /// @param \ttokenAddress            Address of the ERC777 contract used\n    /// @param \tamount                  Amount of tokens transferred to this contract\n\t/// @param \ttotalTokensDeposited    Total amount of tokens deposited by the user\n\tevent ReceivedTokens(address userAddress, address tokenAddress, uint amount, uint totalTokensDeposited);\n\n\t/// @notice Deposit tokens from the user's balance to this contract\n\t/// @param \tamount The number of tokens sent\n    function depositTokens(uint256 amount) external {\n        FactoryStorage.Layout storage store = FactoryStorage.layout();\n\t\trequire(\n\t\t\tIERC20(store.currentERC20).allowance(msg.sender, address(this)) >= amount,\n\t\t\t'PointsDeposit: Not allowed to transfer tokens'\n\t\t);\n\t\trequire(\n\t\t\tIERC20(store.currentERC20).transferFrom(msg.sender, address(this), amount),\n\t\t\t'PointsDeposit: Error transferring tokens'\n\t\t);\n\n\t\tstore.totalUserPoints[msg.sender] += amount;\n\t\tstore.currentUserPoints[msg.sender] += amount;\n\n\t\temit ReceivedTokens(\n            msg.sender,\n            store.currentERC20,\n            amount,\n            store.currentUserPoints[msg.sender]\n        );\n\t}\n}"
    },
    "contracts/Factory/facets/QueryingLogic.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25;\n\nimport { AccessControlEnumerable } from '../../common/DiamondStorage/AccessControlEnumerable.sol';\nimport { FactoryStorage } from \"../AppStorage.sol\";\n\ncontract PointsQuery is AccessControlEnumerable {\n    function getUserPoints(address userAddress) view external returns(uint balance) {\n        balance = FactoryStorage.layout().currentUserPoints[userAddress];\n    }\n\n    function getTotalUserPoints(address userAddress) view external returns(uint balance) {\n        balance = FactoryStorage.layout().totalUserPoints[userAddress];\n    }\n}"
    },
    "contracts/Factory/facets/TokensFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { FactoryStorage } from \"../AppStorage.sol\";\nimport { AccessControlEnumerable } from \"../../common/DiamondStorage/AccessControlEnumerable.sol\";\nimport { FactoryHandlerRoles } from '../AccessControlRoles.sol';\n\n/// @title \tOur Facet creator for tokens\n/// @notice You can use this contract to manage the use of tokens\ncontract TokensFacet is AccessControlEnumerable, FactoryHandlerRoles {\n\t/// @notice Record of a change in accepted tokens\n    /// @param \tcontractAddress contains the address of the tokens contract \n    /// @param \tpriceToDeploy contains the deployment cost for the token\n    /// @param \tresponsible address of the person that implement the new token\n\tevent ChangedToken(address contractAddress, uint priceToDeploy, address responsible);\n\t/// @notice This event stores in the blockchain when the tokens are withdrawed from the contract\n    /// @param \trecipient address who will recieve the tokens\n    /// @param \ttoken contains the address of the tokens contract to withdraw\n\t/// @param \tamount total of tokens to recieve\n\tevent WithdrawTokens(address recipient, address token, uint amount);\n\n\t/// @notice Transfers tokens from the factory to any of the OWNER addresses\n\t/// @dev \tAccessControl makes sure only an OWNER can withdraw\n\t/// @param \tamount\tAmount of tokens to withdraw\n\tfunction withdrawTokens(uint amount) public onlyRole(ADMINISTRATOR) {\n\t\tFactoryStorage.Layout storage store = FactoryStorage.layout();\n\t\tIERC20(store.currentERC20).transfer(msg.sender, amount);\n\t\temit WithdrawTokens(msg.sender, store.currentERC20, amount);\n\t}\n\n\t/// @notice\tAdds an address to the list of allowed minters\n\t/// @param\t_token\tAddress of the new Token\n\t/// @param\t_priceToDeploy\tPrice of deployment for the new Token\n\tfunction changeToken(address _token, uint _priceToDeploy) public onlyRole(ADMINISTRATOR) {\n\t\tFactoryStorage.Layout storage store = FactoryStorage.layout();\n\t\tstore.currentERC20 = _token;\n\t\tstore.deploymentCostForToken[_token] = _priceToDeploy;\n\t\temit ChangedToken(_token, _priceToDeploy, msg.sender);\n\t}\n\n\t/// @notice\tReturns the number of required tokens to deploy a contract\n\t/// @return price \tShows the price of deployment for the token\n\tfunction getDeploymentCost() public view returns (uint price) {\n\t\tFactoryStorage.Layout storage store = FactoryStorage.layout();\n\t\tprice = FactoryStorage.layout().deploymentCostForToken[store.currentERC20];\n\t}\n}"
    },
    "contracts/Factory/facets/WithdrawLogic.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { AccessControlEnumerable } from '../../common/DiamondStorage/AccessControlEnumerable.sol';\nimport { FactoryHandlerRoles } from '../AccessControlRoles.sol';\nimport { FactoryStorage } from \"../AppStorage.sol\";\n\n/// @title \tWithdraw logic for the points system\ncontract PointsWithdraw is AccessControlEnumerable, FactoryHandlerRoles {\n\n    event WithdrewPoints(address user, address token, uint amount);\n\n    function setWithdrawTimeLimit(uint timeInSeconds) public onlyRole(ADMINISTRATOR) {\n        FactoryStorage.layout().transferTimeLimit = timeInSeconds;\n    }\n\n    function roundedTime() internal view returns (uint time) {\n        // Round out by 2 digits\n        time = ((block.timestamp + FactoryStorage.layout().transferTimeLimit) / 100) * 100;\n    }\n\n    function getWithdrawHash(\n        address receiver,\n        address token,\n        uint amount\n    ) public view returns (bytes32) {\n        FactoryStorage.Layout storage facetData = FactoryStorage.layout();\n        require(\n            facetData.currentUserPoints[receiver] >= amount,\n            \"PointsWithdraw: Invalid withdraw amount\"\n        );\n        return keccak256(\n            abi.encodePacked(\n                receiver,\n                token,\n                amount,\n                facetData.currentUserPoints[receiver],\n                roundedTime()\n            )\n        );\n    }\n\n    function getSignedMessageHash(\n        bytes32 messageHash\n    ) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\n        );\n    }\n\n    function recoverSigner(\n        bytes32 signedMessageHash,\n        bytes memory signature\n    ) internal pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\n        return ecrecover(signedMessageHash, v, r, s);\n    }\n\n    function splitSignature(\n        bytes memory sig\n    ) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        require(sig.length == 65, \"invalid signature length\");\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n    }\n\n    function withdraw(\n        uint amount,\n        bytes memory signature\n    ) public {\n\t\tFactoryStorage.Layout storage store = FactoryStorage.layout();\n\n        bytes32 messageHash = getWithdrawHash(msg.sender, store.currentERC20, amount);\n        bytes32 ethSignedMessageHash = getSignedMessageHash(messageHash);\n        require(\n            hasRole(\n                WITHDRAW_SIGNER,\n                recoverSigner(ethSignedMessageHash, signature)\n            ),\n            \"PointsWithdraw: Invalid withdraw request\"\n        );\n        require(\n            store.currentUserPoints[msg.sender] >= amount,\n            \"PointsWithdraw: Insufficient points balance\"\n        );\n        store.currentUserPoints[msg.sender] -= amount;\n        IERC20(store.currentERC20).transfer(msg.sender, amount);\n        emit WithdrewPoints(msg.sender, store.currentERC20, amount);\n    }\n}"
    },
    "contracts/Factory/FacetSource.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\n// Parent classes\nimport { Diamond } from '../diamondStandard/Diamond.sol';\nimport { AccessControlEnumerable } from \"../common/DiamondStorage/AccessControlEnumerable.sol\";\n\n/// @title \tFacet source\n/// @notice Main hub for the ERC721 facets\n/// @dev \tTo be used alongside the Factory\ncontract FacetSource is Diamond, AccessControlEnumerable {\n\tconstructor(address _diamondCut) Diamond(msg.sender, _diamondCut) {}\n}"
    },
    "contracts/Factory/FactoryDiamond.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\n// Parent classes\nimport { Diamond } from '../diamondStandard/Diamond.sol';\nimport { AccessControlEnumerable } from \"../common/DiamondStorage/AccessControlEnumerable.sol\";\nimport { FactoryHandlerRoles } from './AccessControlRoles.sol';\n\n/// @title  RAIR ERC721 Factory\n/// @notice Handles the deployment of ERC721 RAIR Tokens\n/// @author Juan M. Sanchez M.\ncontract FactoryDiamond is Diamond, AccessControlEnumerable, FactoryHandlerRoles {\n\tconstructor(address _diamondCut) Diamond(msg.sender, _diamondCut) {\n\t\t_setRoleAdmin(ADMINISTRATOR, ADMINISTRATOR);\n\t\t_setRoleAdmin(WITHDRAW_SIGNER, ADMINISTRATOR);\n\t\t_grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\t\t_grantRole(ADMINISTRATOR, msg.sender);\n\t\t_grantRole(WITHDRAW_SIGNER, msg.sender);\n\t}\n}"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title IERC165 interface \n/// @notice You can use this contract verify if an interface is supported\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param  interfaceId The interface identifier, as specified in ERC-165\n    /// @dev    Interface identification is specified in ERC-165. This function\n    ///         uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///         `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "contracts/maliciousContracts/receiveEthAttacker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\n/// @title  This is a token protection contract\n/// @notice The function of this contract prevent another contract to recieve the tokens\n/// @dev    This contract will prevent another contract to sustract any token by causing a revert\n/// @dev    The revert will occur if a contract, and not an user, try to buy any token\ncontract ReceiveEthAttacker {\n    constructor() {\n\n    }\n\n    /// @notice Unexpected reverts would stop any token purchase, from the minter or the resale marketplace\n    receive() external payable {\n        require(false, \"Unexpected Revert Attack!\");\n    }\n}"
    },
    "contracts/maliciousContracts/receiveEthTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title  Test contract with a receive function\ncontract ReceiverTest is Ownable {\n    constructor() Ownable(msg.sender) {}\n\n    function withdraw() public onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    receive() external payable {}\n}"
    },
    "contracts/Marketplace/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nstruct feeSplits {\n\taddress recipient;\n\tbool canBeContract;\n\tuint percentage;\n}\n\nstruct mintingOffer {\n\taddress erc721Address;\n\taddress nodeAddress;\n\tuint rangeIndex;\n\tfeeSplits[] fees;\n\tbool visible;\n}\n\nstruct RoleData {\n\tmapping(address => bool) members;\n\tbytes32 adminRole;\n}\n\nstruct AppStorage {\n\t// Access Control Enumerable\n\tmapping(bytes32 => RoleData) _roles;\n\tmapping(bytes32 => EnumerableSet.AddressSet) _roleMembers;\n\t// App\n\tuint16 decimals;\n\tuint decimalPow;\n\tuint nodeFee;\n\tuint treasuryFee;\n\taddress treasuryAddress;\n\tmintingOffer[] mintingOffers;\n\tmapping(address => mapping(uint => uint)) addressToRangeOffer;\n\tmapping(address => uint[]) addressToOffers;\n\t// Always add new fields at the end of the struct, that way the structure can be upgraded\n}\n\nlibrary LibAppStorage {\n\tfunction diamondStorage() internal pure\treturns (AppStorage storage ds) {\n\t\tassembly {\n\t\t\tds.slot := 0\n\t\t}\n\t}\n}\n\n/// @title \tThis is contract to manage the access control of the app market\n/// @notice You can use this contract to administrate roles of the app market\n/// @dev \tNotice that this contract is inheriting from Context\ncontract AccessControlAppStorageEnumerableMarket is Context {\n\tusing EnumerableSet for EnumerableSet.AddressSet;\n\t\n\tAppStorage internal s;\n\n\t/// @notice This event stores in the blockchain when we change an admin role\n    /// @param  role Contains the role we want to update\n    /// @param  previousAdminRole contains the previous status of the role\n\t/// @param  newAdminRole contains the new status of the role\n\tevent RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\t/// @notice This event stores in the blockchain when we grant a role\n    /// @param  role Contains the role we want to update\n    /// @param  account contains the address that we want to grant the role\n\t/// @param  sender contains the address that is changing the role of the account\n\tevent RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\t/// @notice This event stores in the blockchain when we revoke a role\n    /// @param  role Contains the role we want to update\n    /// @param  account contains the address that we want to revoke the role\n\t/// @param  sender contains the address that is changing the role of the account\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n\t/// @notice Allow us to renounce to a role\n\t/// @dev \tCurrently you can only renounce to your own roles\n\t/// @param \trole Contains the role to remove from our account\n\t/// @param \taccount Contains the account that has the role we want to update\n    function renounceRole(bytes32 role, address account) public {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n        _revokeRole(role, account);\n    }\n\n\t/// @notice Allow us to grant a role to an account\n\t/// @dev \tThis function is only available to an account with an Admin role\n\t/// @param \trole Contains the role that we want to grant\n\t/// @param \taccount Contains the account that has the role we want to update\n    function grantRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n\t/// @notice Allow us to revoke a role to an account\n\t/// @dev \tThis function is only available to an account with an Admin role\n\t/// @param \trole Contains the role that we want to revoke\n\t/// @param \taccount Contains the account that has the role we want to update\n    function revokeRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n\t/// @notice Allow us to check the if and account has a selected role\n\t/// @param \trole Contains the role that we want to verify\n\t/// @param \taccount Contains the account address thay we want to verify\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n\t/// @notice Allow us to check the if and account has a selected role\n\t/// @param \trole Contains the role that we want to verify\n\t/// @param \taccount Contains the account address thay we want to verify\n\t/// @return bool that indicates if an account has or not a role\n\tfunction hasRole(bytes32 role, address account) public view returns (bool) {\n\t\treturn s._roles[role].members[account];\n\t}\n\n\t/// @notice Allow us to check the admin role that contains a role\n\t/// @param \trole Contains the role that we want to verify\n\t/// @return bytes that indicates if an account has or not an admin role\n\tfunction getRoleAdmin(bytes32 role) public view returns (bytes32) {\n\t\treturn s._roles[role].adminRole;\n\t}\n\n\t/// @notice Allow us to check the address of an indexed position for the role list\n\t/// @param \trole Contains the role that we want to verify\n\t/// @param \tindex Contains the indexed position to verify inside the role members list\n\t/// @return address that indicates the address indexed in that position\n\tfunction getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n\t\treturn s._roleMembers[role].at(index);\n\t}\n\t\n\t/// @notice Allow us to check total members that has an selected role\n\t/// @param \trole Contains the role that we want to verify\n\t/// @return uint256 that indicates the total accounts with that role\n\tfunction getRoleMemberCount(bytes32 role) public view returns (uint256) {\n\t\treturn s._roleMembers[role].length();\n\t}\n\n\t/// @notice Allow us to modify a rol and set it as an admin role\n\t/// @param \trole Contains the role that we want to modify\n\t/// @param \tadminRole Contains the admin role that we want to set\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n\t\tbytes32 previousAdminRole = getRoleAdmin(role);\n\t\ts._roles[role].adminRole = adminRole;\n\t\temit RoleAdminChanged(role, previousAdminRole, adminRole);\n\t}\n\n\t/// @notice Allow us to grant a role to an account\n\t/// @param \trole Contains the role that we want to grant\n\t/// @param \taccount Contains the account that has the role we want to update\n\tfunction _grantRole(bytes32 role, address account) internal {\n\t\tif (!hasRole(role, account)) {\n\t\t\ts._roles[role].members[account] = true;\n\t\t\temit RoleGranted(role, account, _msgSender());\n\t\t\ts._roleMembers[role].add(account);\n\t\t}\n\t}\n\n\t/// @notice Allow us to revoke a role to an account\n\t/// @param \trole Contains the role that we want to revoke\n\t/// @param \taccount Contains the account that has the role we want to update\n\tfunction _revokeRole(bytes32 role, address account) internal {\n\t\tif (hasRole(role, account)) {\n\t\t\ts._roles[role].members[account] = false;\n\t\t\temit RoleRevoked(role, account, _msgSender());\n\t\t\ts._roleMembers[role].remove(account);\n\t\t}\n\t}\n}"
    },
    "contracts/Marketplace/Facets/FeesFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\nimport '@openzeppelin/contracts/access/IAccessControl.sol';\nimport '../AppStorage.sol';\n\n/// @title This is contract to manage the facet fees\n/// @notice You can use this contract to update the facet and treasury\n/// @dev \tNotice that this contract is inheriting from AccessControlAppStorageEnumerableMarket\ncontract FeesFacet is AccessControlAppStorageEnumerableMarket {\n\tbytes32 public constant MAINTAINER = keccak256(\"MAINTAINER\");\n\t\n\t/// @notice This event stores in the blockchain when we update the decimals of a fee\n    /// @param  decimals Contains the decimals established for the fee\n    /// @param  precalculatedMultiplier Contains the value of the multiplayer for the fee\n\tevent UpdatedDecimals(uint decimals, uint precalculatedMultiplier);\n\t/// @notice This event stores in the blockchain when we update the node fee\n    /// @param  decimals Contains the decimals established for the fee\n    /// @param  newPercentage Contains the value of the percentage to calculate the fee\n\tevent UpdatedNodeFee(uint decimals, uint newPercentage);\n\t/// @notice This event stores in the blockchain when we update the fee of our treasury\n    /// @param  decimals Contains the decimals established for the fee\n    /// @param  newPercentage Contains the value of the percentage to calculate the treasury fee\n\tevent UpdatedTreasuryFee(uint decimals, uint newPercentage);\n\t/// @notice This event stores in the blockchain when we update the decimals of a fee\n    /// @param  newAddress Contains the new address that we set ad treasury\n\tevent UpdatedTreasuryAddress(address newAddress);\n\n\t/// @notice Check the current decimals of the fee\n    /// @return uint16 with the current decimals \n\tfunction getDecimals() public view returns (uint16) {\n\t\treturn s.decimals;\n\t}\n\n\t/// @notice Allow us to update the decimals that we use\n\t///\t@dev\tOnly a MAINTAINER of the contract is allowed to make this change\n\t/// @param \tnewDecimals_ Contains the value of the new decimals that we want to implement\n\tfunction updateDecimals(uint16 newDecimals_) public onlyRole(MAINTAINER) {\n\t\ts.decimals = newDecimals_;\n\t\ts.decimalPow = 10**newDecimals_;\n\t\temit UpdatedDecimals(s.decimals, s.decimalPow);\n\t}\n\n\t/// @notice Allow us to check the value of the fee for the current node\n\t/// @return decimals \tNumber of decimal spaces in the resulting node fee\n\t/// @return nodeFee \tPercentage of any minting offer that belongs to the node address\n\tfunction getNodeFee() public view returns (uint16 decimals, uint nodeFee) {\n\t\treturn (s.decimals, s.nodeFee);\n\t}\n\n\t/// @notice Allow us to update the current fee of the node\n\t///\t@dev\tOnly a MAINTAINER of the contract is allowed to make this change\n\t/// @param \tnewFee_ establish the new value that we want to set as fee\n\tfunction updateNodeFee(uint newFee_) public onlyRole(MAINTAINER) {\n\t\trequire(newFee_ <= 100 * s.decimalPow, \"Marketplace: Invalid Fee!\");\n\t\ts.nodeFee = newFee_;\n\t\temit UpdatedNodeFee(s.decimals, newFee_);\n\t}\n\n\t/// @notice Allow us to check the current Treasury fee\n\t/// @return decimals containt the current decimals that use the fee\n\t/// @return treasuryFee constain the current fee of the treasury\n\tfunction getTreasuryFee() public view returns (uint16 decimals, uint treasuryFee) {\n\t\treturn (s.decimals, s.treasuryFee);\n\t}\n\n\t/// @notice Allow us to modify the current treasury fee\n\t///\t@dev\tOnly a MAINTAINER he new fee that we want to implement for the treasury\n\t/// @param \tnewFee_ establish the new value that we want to set as treasury fee\n\tfunction updateTreasuryFee(uint newFee_) public onlyRole(MAINTAINER) {\n\t\trequire(newFee_ <= 100 * s.decimalPow, \"Marketplace: Invalid Fee!\");\n\t\ts.treasuryFee = newFee_;\n\t\temit UpdatedTreasuryFee(s.decimals, newFee_);\n\t}\n\n\t/// @notice Allow us to check the current Treasury fee\n\t/// @return address which contains the treasury contract address\n\tfunction getTreasuryAddress() public view returns (address) {\n\t\treturn s.treasuryAddress;\n\t}\n\n\t/// @notice Allow us to modify the address that we use as treasury\n\t///\t@dev\tOnly a MAINTAINER he new fee that we want to implement for the treasury\n\t/// @param \tnewAddress_ contains the new address that we want to establish as treasury\n\tfunction updateTreasuryAddress(address newAddress_) public onlyRole(MAINTAINER) {\n\t\ts.treasuryAddress = newAddress_;\n\t\temit UpdatedTreasuryAddress(newAddress_);\n\t}\n}"
    },
    "contracts/Marketplace/Facets/MintingOffersFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\nimport '@openzeppelin/contracts/access/IAccessControl.sol';\nimport '../AppStorage.sol';\n\ninterface IRAIR721 {\n\tstruct range {\n\t\tuint rangeStart;\n\t\tuint rangeEnd;\n\t\tuint tokensAllowed;\n\t\tuint mintableTokens;\n\t\tuint lockedTokens;\n\t\tuint rangePrice;\n\t\tstring rangeName;\n\t}\n\n\t/// @notice This function returns the information of the selected range\n\t/// @param rangeId \t\t  Contains the specific range that we want to check\n\t/// @return data\t\t  Contains the data inside the range\n\t/// @return productIndex  Contains the index of the products for the range\n\tfunction rangeInfo(uint rangeId) external view returns(range memory data, uint productIndex);\n\t/// @notice This function allow us to mint token from a specific range \n\t/// @param to Contains the address that will mint the token\n    /// @param rangeId Contains the range identification where we want to mint\n\t/// @param indexInRange Contains the index inside the range that we want to use for minting \n\tfunction mintFromRange(address to, uint rangeId, uint indexInRange) external;\n}\n\n\n/// @title  RAIR Diamond - Minting offers facet\n/// @notice Facet in charge of the minting offers in the RAIR Marketplace\n/// @author Juan M. Sanchez M.\n/// @dev \tNotice that this contract is inheriting from AccessControlAppStorageEnumerableMarket\ncontract MintingOffersFacet is AccessControlAppStorageEnumerableMarket {\n\n\t/// @notice This event stores in the blockchain when a Minting Offer is Added\n    /// @param  erc721Address Contains the address of the erc721\n    /// @param  rangeIndex contains the id of the minted token\n\t/// @param  rangeName contains the name of the range where the token is\n\t/// @param  price Contains the price of the offer fot the token\n    /// @param  feeSplitsLength contains the previous status of the offer\n    /// @param  feeSplitsLength Contains the visibility of the offer\n\t/// @param  offerIndex contains the new status of the offer\n\tevent AddedMintingOffer(address erc721Address, uint rangeIndex, string rangeName, uint price, uint feeSplitsLength, bool visible, uint offerIndex);\n\tevent UpdatedMintingOffer(address erc721Address, uint rangeIndex, uint feeSplitsLength, bool visible, uint offerIndex);\n\t\n\tevent MintedToken(address erc721Address, uint rangeIndex, uint tokenIndex, address buyer);\n\n\tmodifier checkMinterRole(address erc721Address) {\n\t\trequire(hasMinterRole(erc721Address), \"Minter Marketplace: This Marketplace isn't a Minter!\");\n\t\t_;\n\t}\n\n\tmodifier mintingOfferExists(uint offerIndex_) {\n\t\trequire(s.mintingOffers.length > offerIndex_, \"Minting Marketplace: Minting Offer doesn't exist\");\n\t\t_;\n\t}\n\n\tmodifier offerDoesntExist(address erc721Address, uint rangeIndex) {\n\t\trequire(s.addressToRangeOffer[erc721Address][rangeIndex] == 0, \"Minter Marketplace: Range already has an offer\");\n\t\tif (s.addressToRangeOffer[erc721Address][rangeIndex] == 0 && s.mintingOffers.length > 0) {\n\t\t\trequire(s.mintingOffers[0].erc721Address != erc721Address ||\n\t\t\t\t\t\ts.mintingOffers[0].rangeIndex != rangeIndex,\n\t\t\t\t\t\t\t\"Minter Marketplace: Range already has an offer\");\n\t\t}\n\t\t_;\n\t}\n\n\tfunction _checkCreatorRole(address erc721Address) internal view returns (bool) {\n\t\trequire(\n\t\t\tIAccessControl(erc721Address).hasRole(bytes32(0x00), address(msg.sender)) ||\n\t\t\tIAccessControl(erc721Address).hasRole(bytes32(keccak256(\"CREATOR\")), address(msg.sender)),\n\t\t\t\"Minter Marketplace: Sender isn't the creator of the contract!\");\n\t\treturn true;\n\t}\n\n\t/// @notice Utility function to verify that the recipient of a custom splits ISN'T a contract\n\t/// @dev \tThis isn't a foolproof function, a contract running code in it's constructor has a code size of 0\n\t/// @param \taddr \tAddress to verify\n\t/// @return bool that indicates if the address is a contract or not\n\tfunction isContract(address addr) internal view returns (bool) {\n\t\tuint size;\n\t\tassembly { size := extcodesize(addr) }\n\t\treturn size > 0;\n\t}\n\n\t/// @notice Utility function to verify if the Marketplace has a MINTER role\n\t/// @param  erc721Address \tAddress of the ERC721 token with AccessControl\n\t/// @return bool that indicates if the marketplace has a `MINTER` role or not\n\tfunction hasMinterRole(address erc721Address) internal view returns (bool) {\n\t\treturn IAccessControl(erc721Address).hasRole(bytes32(keccak256(\"MINTER\")), address(this));\n\t}\n\n\t/// @notice Returns the number of offers for a specific ERC721 address\n\t/// @param  erc721Address \tAddress of the ERC721 token\n\t/// @return uint with the total of offers\n\tfunction getOffersCountForAddress(address erc721Address) public view returns (uint) {\n\t\treturn s.addressToOffers[erc721Address].length;\n\t}\n\n\t/// @notice Returns the number of all the minting offers \n\t/// @return uint with the total of offers\n\tfunction getTotalOfferCount() public view returns (uint) {\n\t\treturn s.mintingOffers.length;\n\t}\n\n\t/// @notice This functions show us the information of an offer asociated to a marketplace\n\t/// @param erc721Address Contains the facet addresses and function selectors\n    /// @param rangeIndex Contains the facet addresses and function selectors\n\t/// @return offerIndex Show us the indexed position of the offer\n\t/// @return mintOffer Show us the information about the minting offer \n\t/// @return rangeData Show us the data about the selected range\n\t/// @return productIndex Show us the indexed position for the product inside the range\n\tfunction getOfferInfoForAddress(address erc721Address, uint rangeIndex) public view returns (uint offerIndex, mintingOffer memory mintOffer, IRAIR721.range memory rangeData, uint productIndex) {\n\t\tmintingOffer memory selectedOffer = s.mintingOffers[s.addressToOffers[erc721Address][rangeIndex]];\n\t\t(rangeData, productIndex) = IRAIR721(selectedOffer.erc721Address).rangeInfo(selectedOffer.rangeIndex);\n\t\tofferIndex = s.addressToOffers[erc721Address][rangeIndex];\n\t\tmintOffer = selectedOffer;\n\t}\n\n\t/// @notice This function show us the information of an selected minting offer\n\t/// @param \t\tofferIndex Contains the facet addresses and function selectors\n\t/// @return \tmintOffer Show us the information about the minting offer \n\t/// @return \trangeData Show us the data about the selected range\n\t/// @return \tproductIndex Show us the indexed position for the product inside the range\n\tfunction getOfferInfo(uint offerIndex) public view returns (mintingOffer memory mintOffer, IRAIR721.range memory rangeData, uint productIndex) {\n\t\tmintingOffer memory selectedOffer = s.mintingOffers[offerIndex];\n\t\tmintOffer = selectedOffer;\n\t\t(rangeData, productIndex) = IRAIR721(selectedOffer.erc721Address).rangeInfo(selectedOffer.rangeIndex);\n\t}\n\n\t/// @notice This function allow us to add a new minting offer\n\t/// @param erc721Address_ Contains the address of the minter marketplace contract\n\t/// @param rangeIndex_ Contains the index location of the range where the offer will be placed\n\t/// @param splits Contains the shares and address to pay when the offer is succesfull \n\t/// @param visible_ Contains a boolean to set if the offer is public or not \n\t/// @param nodeAddress_ Contains address of the node where the offer was placed\n\tfunction addMintingOffer(\n\t\taddress erc721Address_,\n\t\tuint rangeIndex_,\n\t\tfeeSplits[] calldata splits,\n\t\tbool visible_,\n\t\taddress nodeAddress_\n\t) external {\n\t\t_addMintingOffer(erc721Address_, rangeIndex_, splits, visible_, nodeAddress_);\n\t}\n\n\t/// @notice This function allow us to create a group of minting offers in a single call\n\t/// @param erc721Address_ Contains the address of the minter marketplace contract\n\t/// @param rangeIndexes Contains the collection of ranges where the offer will be placed\n\t/// @param splits Contains the shares and address to pay when the offer is succesfull \n\t/// @param visibility Contains a collection of booleans that set the offer as public or not \n\t/// @param nodeAddress_ Contains address of the node where the offer was placed\n\tfunction addMintingOfferBatch(\n\t\taddress erc721Address_,\n\t\tuint[] calldata rangeIndexes,\n\t\tfeeSplits[][] calldata splits,\n\t\tbool[] calldata visibility,\n\t\taddress nodeAddress_\n\t) external {\n\t\trequire(rangeIndexes.length > 0, \"Minter Marketplace: No offers sent!\");\n\t\trequire(rangeIndexes.length == visibility.length && splits.length == visibility.length, \"Minter Marketplace: Arrays should have the same length\");\n\t\tfor (uint i = 0; i < rangeIndexes.length; i++) {\n\t\t\t_addMintingOffer(erc721Address_, rangeIndexes[i], splits[i], visibility[i], nodeAddress_);\n\t\t}\n\t}\n\n\t/// @notice This function allow us to add a new minting offer\n\t/// @dev \tThis function requires that account has the role of `CREATOR`\n\t/// @dev \tThis function requires that the marketplace is defined as MINTER\n\t/// @dev \tThis function requires that the range is available to create a new offer\n\t/// @param erc721Address_ Contains the address of the minter marketplace contract\n\t/// @param rangeIndex_ Contains the index location of the range where the offer will be placed\n\t/// @param splits Contains the shares and address to pay when the offer is succesfull \n\t/// @param visible_ Contains a boolean to set if the offer is public or not \n\t/// @param nodeAddress_ Contains address of the node where the offer was placed\n\tfunction _addMintingOffer(\n\t\taddress erc721Address_,\n\t\tuint rangeIndex_,\n\t\tfeeSplits[] memory splits,\n\t\tbool visible_,\n\t\taddress nodeAddress_\n\t) internal checkMinterRole(erc721Address_) offerDoesntExist(erc721Address_, rangeIndex_) {\n\t\t_checkCreatorRole(erc721Address_);\n\t\tmintingOffer storage newOffer = s.mintingOffers.push();\n\t\t(IRAIR721.range memory rangeData,) = IRAIR721(erc721Address_).rangeInfo(rangeIndex_);\n\t\trequire(rangeData.mintableTokens > 0, \"Minter Marketplace: Offer doesn't have tokens available!\");\n\t\tnewOffer.erc721Address = erc721Address_;\n\t\tnewOffer.nodeAddress = nodeAddress_;\n\t\tnewOffer.rangeIndex = rangeIndex_;\n\t\tnewOffer.visible = visible_;\n\t\tif (rangeData.rangePrice > 0) {\n\t\t\tuint totalPercentage = s.nodeFee + s.treasuryFee;\n\t\t\tuint totalFunds = rangeData.rangePrice * totalPercentage / (100 * s.decimalPow);\n\t\t\tfor (uint i = 0; i < splits.length; i++) {\n\t\t\t\trequire(splits[i].canBeContract || !isContract(splits[i].recipient), \"Minter Marketplace: Contracts can't be recipients of the splits\");\n\t\t\t\tuint splitForPercentage = rangeData.rangePrice * splits[i].percentage / (100 * s.decimalPow);\n\t\t\t\trequire(\n\t\t\t\t\tsplitForPercentage > 0,\n\t\t\t\t\t\"Minter Marketplace: A percentage on the array will result in an empty transfer\"\n\t\t\t\t);\n\t\t\t\ttotalFunds += splitForPercentage;\n\t\t\t\ttotalPercentage += splits[i].percentage;\n\t\t\t\tnewOffer.fees.push(splits[i]);\n\t\t\t}\n\t\t\trequire(totalPercentage == (100 * s.decimalPow), \"Minter Marketplace: Fees don't add up to 100%\");\n\t\t\trequire(totalFunds == rangeData.rangePrice, \"Minter Marketplace: Current fee configuration will result in missing funds\");\n\t\t}\n\t\ts.addressToOffers[erc721Address_].push(s.mintingOffers.length - 1);\n\t\ts.addressToRangeOffer[erc721Address_][rangeIndex_] = s.mintingOffers.length - 1;\n\t\temit AddedMintingOffer(erc721Address_, rangeIndex_, rangeData.rangeName, rangeData.rangePrice, splits.length, visible_, s.mintingOffers.length - 1);\n\t}\n\n\t/// @notice This function allow us to update the parameters of a minting offers\n\t/// @dev \tThis function requires that the mintingOfferExists points to an valid offer  \n\t/// @param \tmintingOfferId_  Contains index location of the minting offer\n\t/// @param \tsplits_ \t\t Contains the shares and address to pay when the offer is succesfull \n\t/// @param \tvisible_    \t Contains a boolean to set if the offer is public or not \n\tfunction updateMintingOffer (\n\t\tuint mintingOfferId_,\n\t\tfeeSplits[] memory splits_,\n\t\tbool visible_\n\t) external mintingOfferExists(mintingOfferId_) {\n\t\t_updateMintingOffer(mintingOfferId_, splits_, visible_);\n\t}\n\n\t/// @notice This function allow us to update the parameters of a minting offers \n\t/// @param \tmintingOfferId_  Contains index location of the minting offer\n\t/// @param \tsplits_ \t\t Contains the shares and address to pay when the offer is succesfull \n\t/// @param \tvisible_         Contains a boolean to set if the offer is public or not \n\tfunction _updateMintingOffer (\n\t\tuint mintingOfferId_,\n\t\tfeeSplits[] memory splits_,\n\t\tbool visible_\n\t) internal {\n\t\tmintingOffer storage selectedOffer = s.mintingOffers[mintingOfferId_];\n\t\t_checkCreatorRole(selectedOffer.erc721Address);\n\t\trequire(\n\t\t\thasMinterRole(selectedOffer.erc721Address),\n\t\t\t\"Minter Marketplace: This Marketplace isn't a Minter!\"\n\t\t);\n\t\t(IRAIR721.range memory rangeData,) = IRAIR721(selectedOffer.erc721Address).rangeInfo(selectedOffer.rangeIndex);\n\t\tuint totalPercentage = s.nodeFee + s.treasuryFee;\n\t\tdelete selectedOffer.fees;\n\t\tfor (uint i = 0; i < splits_.length; i++) {\n\t\t\trequire(splits_[i].canBeContract || !isContract(splits_[i].recipient), \"Minter Marketplace: Contracts can't be recipients of fees\");\n\t\t\trequire(\n\t\t\t\trangeData.rangePrice * splits_[i].percentage / (100 * s.decimalPow) > 0,\n\t\t\t\t\"Minter Marketplace: A percentage on the array will result in an empty transfer\"\n\t\t\t);\n\t\t\ttotalPercentage += splits_[i].percentage;\n\t\t\tselectedOffer.fees.push(splits_[i]);\n\t\t}\n\t\trequire(totalPercentage == (100 * s.decimalPow), \"Minter Marketplace: Fees don't add up to 100%\");\n\t\tselectedOffer.visible = visible_;\n\t\temit UpdatedMintingOffer(\n\t\t\tselectedOffer.erc721Address,\n\t\t\tselectedOffer.rangeIndex,\n\t\t\tselectedOffer.fees.length,\n\t\t\tselectedOffer.visible,\n\t\t\tmintingOfferId_\n\t\t);\n\t}\n\n\t/// @notice This function allow us to buy a minting offers\n\t/// @dev \tThis function requires that the mintingOfferExists points to an valid offer  \n\t/// @param \tofferIndex_  Contains index location of the offer\n\t/// @param \ttokenIndex_  Contains the id of the tokens that we want to mint\n\tfunction buyMintingOffer(uint offerIndex_, uint tokenIndex_) public mintingOfferExists(offerIndex_) payable {\n\t\tmintingOffer storage selectedOffer = s.mintingOffers[offerIndex_];\n\t\trequire(selectedOffer.visible, \"Minter Marketplace: This offer is not ready to be sold!\");\n\t\trequire(hasMinterRole(selectedOffer.erc721Address), \"Minter Marketplace: This Marketplace isn't a Minter!\");\n\t\t(IRAIR721.range memory rangeData,) = IRAIR721(selectedOffer.erc721Address).rangeInfo(selectedOffer.rangeIndex);\n\t\tif (rangeData.rangePrice > 0) {\n\t\t\trequire(rangeData.rangePrice <= msg.value, \"Minter Marketplace: Insufficient funds!\");\n\t\t\tif (msg.value - rangeData.rangePrice > 0) {\n\t\t\t\tpayable(msg.sender).transfer(msg.value - rangeData.rangePrice);\n\t\t\t}\n\t\t\tuint totalTransferred = rangeData.rangePrice * (s.nodeFee + s.treasuryFee) / (100 * s.decimalPow);\n\t\t\tpayable(selectedOffer.nodeAddress).transfer(rangeData.rangePrice * s.nodeFee / (100 * s.decimalPow));\n\t\t\tpayable(s.treasuryAddress).transfer(rangeData.rangePrice * s.treasuryFee / (100 * s.decimalPow));\n\t\t\tuint auxMoneyToBeSent;\n\t\t\tfor (uint i = 0; i < selectedOffer.fees.length; i++) {\n\t\t\t\tauxMoneyToBeSent = rangeData.rangePrice * selectedOffer.fees[i].percentage / (100 * s.decimalPow);\n\t\t\t\ttotalTransferred += auxMoneyToBeSent;\n\t\t\t\tpayable(selectedOffer.fees[i].recipient).transfer(auxMoneyToBeSent);\n\t\t\t}\n\t\t\trequire(totalTransferred == rangeData.rangePrice, \"Minter Marketplace: Error transferring funds!\");\n\t\t}\n\t\t_buyMintingOffer(selectedOffer.erc721Address, selectedOffer.rangeIndex, tokenIndex_, msg.sender);\n\t}\n\n\t/// @notice This function allow us to buy a collection of minting offers\n\t/// @dev \tThis function requires that the mintingOfferExists points to an valid offer  \n\t/// @param \tofferIndex_  \tContains index location of the offer\n\t/// @param \ttokenIndexes\tContains the collection of tokens that we want to mint\n\t/// @param \trecipients \t\tContains the collection of addresses that will receive\n\tfunction buyMintingOfferBatch(\n\t\tuint offerIndex_,\n\t\tuint[] calldata tokenIndexes,\n\t\taddress[] calldata recipients\t\t\n\t) external mintingOfferExists(offerIndex_) payable {\n\t\trequire(tokenIndexes.length > 0, \"Minter Marketplace: No tokens sent!\");\n\t\trequire(tokenIndexes.length == recipients.length, \"Minter Marketplace: Tokens and Addresses should have the same length\");\n\t\tmintingOffer storage selectedOffer = s.mintingOffers[offerIndex_];\n\t\trequire(selectedOffer.visible, \"Minter Marketplace: This offer is not ready to be sold!\");\n\t\trequire(hasMinterRole(selectedOffer.erc721Address), \"Minter Marketplace: This Marketplace isn't a Minter!\");\n\t\t(IRAIR721.range memory rangeData,) = IRAIR721(selectedOffer.erc721Address).rangeInfo(selectedOffer.rangeIndex);\n\t\tuint i;\n\t\tif (rangeData.rangePrice > 0) {\n\t\t\trequire((rangeData.rangePrice * tokenIndexes.length) <= msg.value, \"Minter Marketplace: Insufficient funds!\");\n\t\t\tif (msg.value - (rangeData.rangePrice * tokenIndexes.length) > 0) {\n\t\t\t\tpayable(msg.sender).transfer(msg.value - (rangeData.rangePrice * tokenIndexes.length));\n\t\t\t}\n\t\t\tuint totalTransferred = (rangeData.rangePrice * tokenIndexes.length) * (s.nodeFee + s.treasuryFee) / (100 * s.decimalPow);\n\t\t\tpayable(selectedOffer.nodeAddress).transfer((rangeData.rangePrice * tokenIndexes.length) * s.nodeFee / (100 * s.decimalPow));\n\t\t\tpayable(s.treasuryAddress).transfer((rangeData.rangePrice * tokenIndexes.length) * s.treasuryFee / (100 * s.decimalPow));\n\t\t\tuint auxMoneyToBeSent;\n\t\t\tfor (i = 0; i < selectedOffer.fees.length; i++) {\n\t\t\t\tauxMoneyToBeSent = (rangeData.rangePrice * tokenIndexes.length) * selectedOffer.fees[i].percentage / (100 * s.decimalPow);\n\t\t\t\ttotalTransferred += auxMoneyToBeSent;\n\t\t\t\tpayable(selectedOffer.fees[i].recipient).transfer(auxMoneyToBeSent);\n\t\t\t}\n\t\t\trequire(totalTransferred == (rangeData.rangePrice * tokenIndexes.length), \"Minter Marketplace: Error transferring funds!\");\n\t\t}\n\t\tfor (i = 0; i < tokenIndexes.length; i++) {\n\t\t\t_buyMintingOffer(selectedOffer.erc721Address, selectedOffer.rangeIndex, tokenIndexes[i], recipients[i]);\n\t\t}\n\t}\n\n\t/// @notice This function is in charge of buying a desired minting offer \n\t/// @param erc721Address  Contains the address where the offer is located\n\t/// @param rangeIndex\t  Contains the index location of the range where the token is \n\t/// @param tokenIndex  \t  Contains the index location of the token to buy \n\t/// @param recipient   \t  Contains the address of the recipient of the token\n\tfunction _buyMintingOffer(address erc721Address, uint rangeIndex, uint tokenIndex, address recipient) internal {\n\t\tIRAIR721(erc721Address).mintFromRange(recipient, rangeIndex, tokenIndex);\n\t\temit MintedToken(erc721Address, rangeIndex, tokenIndex, recipient);\n\t}\n}"
    },
    "contracts/Marketplace/Facets/ResalesFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ResaleStorage } from \"../Storage/ResaleStorage.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { AccessControlAppStorageEnumerableMarket } from \"../AppStorage.sol\";\n\n/// @title  RAIR Diamond - Resale Marketplace facet\n/// @notice Facet in charge of transfering NFTs and funds\n/// @author Juan M. Sanchez M.\n/// @dev \tUses signed messages for gasless offer postings\ncontract ResaleFacet is AccessControlAppStorageEnumerableMarket {\n\tbytes32 private constant CREATOR = keccak256(\"CREATOR\");\n\tbytes32 private constant DEFAULT_ADMIN_ROLE = 0x0;\n\tbytes32 public constant MAINTAINER = keccak256(\"MAINTAINER\");\n\tbytes32 public constant RESALE_ADMIN = keccak256(\"RESALE_ADMIN\");\n\n    event TokenSold(address erc721Address, address buyer, address seller, uint token, uint tokenPrice);\n    \n    modifier onlyOwnerOfContract(address erc721) {\n        ResaleStorage.Layout storage data = ResaleStorage.layout();\n        require(\n            AccessControlAppStorageEnumerableMarket(erc721).hasRole(CREATOR, msg.sender) ||\n            AccessControlAppStorageEnumerableMarket(erc721).hasRole(DEFAULT_ADMIN_ROLE, msg.sender),\n            \"Resale: Only the owner of a contract can set custom royalties\"\n        );\n        _;\n    }\n\n    function setPurchaseGracePeriod (uint value) public onlyRole(MAINTAINER) {\n        ResaleStorage.layout().purchaseGracePeriod = value;\n    }\n\n    function setDecimalPow (uint value) public onlyRole(MAINTAINER) {\n        ResaleStorage.layout().decimalPow = value;\n    }\n\n    function setRoyalties(\n      address erc721,\n      ResaleStorage.feeSplits[] calldata fees\n    ) onlyOwnerOfContract(erc721)\n      external\n    {\n        for (uint i = 0; i < fees.length; i++) {\n            ResaleStorage.layout().royaltySplits[erc721].push(fees[i]);\n        }\n    }\n\n    function getRoyalties(address erc721) public view returns (ResaleStorage.feeSplits[] memory) {\n        return ResaleStorage.layout().royaltySplits[erc721];\n    }\n\n    function roundedTime() internal view returns (uint time) {\n        // Round out by 2 digits\n        time = (block.timestamp / 100) * 100;\n        time += ResaleStorage.layout().purchaseGracePeriod;\n    }\n\n    function generateResaleHash (\n      address erc721,\n      address buyer,\n      address seller,\n      uint token,\n      uint tokenPrice,\n      address nodeAddress\n    ) public view returns (bytes32) {\n        require(\n            IERC721(erc721).isApprovedForAll(seller, address(this)) ||\n            IERC721(erc721).getApproved(token) == address(this),\n            \"Resale: Marketplace isn't approved for transfers\"\n        );\n        return keccak256(\n            abi.encodePacked(\n                erc721,\n                buyer,\n                seller,\n                token,\n                tokenPrice,\n                nodeAddress,\n                roundedTime()\n            )\n        );\n    }\n\n    function getSignedMessageHash(\n        bytes32 messageHash\n    ) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\n        );\n    }\n\n    function recoverSigner(\n        bytes32 signedMessageHash,\n        bytes memory signature\n    ) internal pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\n        return ecrecover(signedMessageHash, v, r, s);\n    }\n\n    function splitSignature(\n        bytes memory sig\n    ) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        require(sig.length == 65, \"Resale: invalid signature length\");\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n    }\n\n    function purchaseTokenOffer(\n        address erc721,\n        address buyer,\n        address seller,\n        uint token,\n        uint tokenPrice,\n        address nodeAddress,\n        bytes memory signature\n    ) public payable {\n        ResaleStorage.feeSplits[] storage royaltyData = ResaleStorage.layout().royaltySplits[erc721];\n        bytes32 messageHash = generateResaleHash(erc721, buyer, seller, token, tokenPrice, nodeAddress);\n        bytes32 ethSignedMessageHash = getSignedMessageHash(messageHash);\n        require(\n            hasRole(RESALE_ADMIN, recoverSigner(ethSignedMessageHash, signature)),\n            \"Resale: Invalid withdraw request\"\n        );\n        require(tokenPrice <= msg.value, \"Resale: Insufficient funds!\");\n        uint leftoverForSeller = tokenPrice;\n        if (msg.value - tokenPrice > 0) {\n            payable(msg.sender).transfer(msg.value - tokenPrice);\n        }\n\n        uint toPay = tokenPrice * s.nodeFee / (100 * s.decimalPow);\n        payable(nodeAddress).transfer(toPay);\n        uint totalTransferred = toPay;\n        leftoverForSeller -= toPay;\n\n        toPay = tokenPrice * s.treasuryFee / (100 * s.decimalPow);\n        payable(s.treasuryAddress).transfer(toPay);\n        totalTransferred += toPay;\n        leftoverForSeller -= toPay;\n\n        for (uint i = 0; i < royaltyData.length; i++) {\n            toPay = tokenPrice * royaltyData[i].percentage / (100 * s.decimalPow);\n            payable(royaltyData[i].recipient).transfer(toPay);\n            totalTransferred += toPay;\n            leftoverForSeller -= toPay;\n        }\n        payable(address(seller)).transfer(leftoverForSeller);\n        totalTransferred += leftoverForSeller;\n        require(totalTransferred == tokenPrice, \"Resale: Error transferring funds!\");\n        IERC721(erc721).transferFrom(seller, buyer, token);\n        emit TokenSold(erc721, buyer, seller, token, tokenPrice);\n    }\n}"
    },
    "contracts/Marketplace/MarketplaceDiamond.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\n// Parent classes\nimport './AppStorage.sol';\nimport '../diamondStandard/Diamond.sol';\n\n/// @title  RAIR ERC721 Marketplace Diamond\n/// @notice Handles the trading of ERC721 RAIR Tokens\n/// @author Juan M. Sanchez M.\n/// @dev \tNotice this contract is inheriting from Diamond & AccessControlAppStorageEnumerableMarket\ncontract MarketplaceDiamond is Diamond, AccessControlAppStorageEnumerableMarket {\n\tbytes32 public constant MAINTAINER = keccak256(\"MAINTAINER\");\n\tbytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\tconstructor(address _diamondCut) Diamond(msg.sender, _diamondCut) {\n\t\ts.decimals = 3;\n\t\ts.decimalPow = 10**3;\n\t\ts.nodeFee = 1 * s.decimalPow;\n\t\ts.treasuryFee = 9 * s.decimalPow;\n\t\t_setRoleAdmin(MAINTAINER, MAINTAINER);\n\t\t_grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\t\t_grantRole(MAINTAINER, msg.sender);\n\t}\n}"
    },
    "contracts/Marketplace/Storage/ResaleStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nlibrary ResaleStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('rair.contracts.storage.resaleOffers');\n\n    struct feeSplits {\n        address recipient;\n        uint percentage;\n    }\n\n    struct Layout {\n        mapping(address => feeSplits[]) royaltySplits;\n        mapping(address => address) contractOwner;\n        uint purchaseGracePeriod;\n        uint decimalPow;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}"
    },
    "contracts/tokens/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.25;\n\n/// @dev Interface for the NFT Royalty Standard\n///\ninterface IERC2981 {\n    /// ERC165 bytes to add to interface array - set in parent contract\n    /// implementing this standard\n    ///\n    /// bytes4(keccak256(\"royaltyInfo(uint256,uint256)\")) == 0x2a55205a\n    /// bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\n    /// _registerInterface(_INTERFACE_ID_ERC2981);\n\n    /// @notice Called with the sale price to determine how much royalty\n    //          is owed and to whom.\n    /// @param _tokenId - the NFT asset queried for royalty information\n    /// @param _salePrice - the sale price of the NFT asset specified by _tokenId\n    /// @return receiver - address of who should be sent the royalty payment\n    /// @return royaltyAmount - the royalty payment amount for _salePrice\n    function royaltyInfo(\n        uint256 _tokenId,\n        uint256 _salePrice\n    ) external view returns (\n        address receiver,\n        uint256 royaltyAmount\n    );\n}\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}"
    },
    "contracts/tokens/RAIR-721/AccessControlRoles.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\nabstract contract ERC721AccessControlRoles {\n\tbytes32 public constant TRADER = keccak256(\"TRADER\");\n\tbytes32 public constant MINTER = keccak256(\"MINTER\");\n\tbytes32 public constant CREATOR = keccak256(\"CREATOR\");\n}"
    },
    "contracts/tokens/RAIR-721/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\nlibrary ERC721Storage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('rair.contracts.storage.RAIR721');\n\n    struct product {\n        uint startingToken;\n        uint endingToken;\n        uint mintableTokens;\n        string name;\n        uint[] rangeList;\n    }\n\n    struct range {\n        uint rangeStart;\n        uint rangeEnd;\n        uint tokensAllowed;\n        uint mintableTokens;\n        uint lockedTokens;\n        uint rangePrice;\n        string rangeName;\n    }\n\n    struct Layout {\n        // Base ERC721\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n        // ERC721 enumerable extension\n        mapping(address owner => mapping(uint256 index => uint256)) _ownedTokens;\n        mapping(uint256 tokenId => uint256) _ownedTokensIndex;\n        uint256[] _allTokens;\n        mapping(uint256 tokenId => uint256) _allTokensIndex;\n        // RAIR exclusive\n        string baseURI;\n        address factoryAddress;\n        uint16 royaltyFee;\n        product[] products;\n        range[] ranges;\n        mapping(uint => uint) tokenToProduct;\n        mapping(uint => uint) tokenToRange;\n        mapping(uint => string) uniqueTokenURI;\n        mapping(uint => string) productURI;\n        mapping(uint => bool) appendTokenIndexToProductURI;\n        bool appendTokenIndexToBaseURI;\n        mapping(uint => uint[]) tokensByProduct;\n        string contractMetadataURI;\n        mapping(uint => uint) rangeToProduct;\n        mapping(uint => bool) _minted;\n        // August 2022 - Metadata File Extension Update\n        mapping(uint => string) rangeURI;\n        mapping(uint => bool) appendTokenIndexToRangeURI;\n        string _metadataExtension;\n        // March 2024 - Optional trader role\n        bool requiresTrader;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}"
    },
    "contracts/tokens/RAIR-721/Facets/ERC721EnumerableFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.25;\n\nimport {ERC721Facet} from \"./ERC721Facet.sol\";\nimport {IERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {ERC721Storage} from \"../AppStorage.sol\";\n\n// Copy of the OpenZeppelin code using diamond storage\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds enumerability\n * of all the token ids in the contract as well as all token ids owned by each account.\n *\n * CAUTION: `ERC721` extensions that implement custom `balanceOf` logic, such as `ERC721Consecutive`,\n * interfere with enumerability and should not be used together with `ERC721Enumerable`.\n */\ncontract ERC721EnumerableFacet is ERC721Facet, IERC721Enumerable {\n    /**\n     * @dev An `owner`'s token query was out of bounds for `index`.\n     *\n     * NOTE: The owner being `address(0)` indicates a global out of bounds index.\n     */\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\n\n    /**\n     * @dev Batch mint is not allowed.\n     */\n    error ERC721EnumerableForbiddenBatchMint();\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view override(IERC165, ERC721Facet) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        ERC721Storage.Layout storage store = ERC721Storage.layout();\n        return store._ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        ERC721Storage.Layout storage store = ERC721Storage.layout();\n        return store._allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        ERC721Storage.Layout storage store = ERC721Storage.layout();\n        return store._allTokens[index];\n    }\n\n    /**\n     * @dev See {ERC721-_update}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n\n        // Custom functionality for rair\n        // If it's not minting or burning \n\t\tif (previousOwner != address(0) && to != address(0)) {\n            ERC721Storage.Layout storage store = ERC721Storage.layout();\n            if (store.requiresTrader) {\n\t\t\t    _checkRole(TRADER, msg.sender);\n            }\n\t\t\trequire(\n                store.ranges[store.tokenToRange[tokenId]].lockedTokens == 0,\n                \"RAIR ERC721: Cannot transfer from a locked range!\"\n            );\n\t\t}\n\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n\n        return previousOwner;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = balanceOf(to) - 1;\n        ERC721Storage.Layout storage store = ERC721Storage.layout();\n        store._ownedTokens[to][length] = tokenId;\n        store._ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        ERC721Storage.Layout storage store = ERC721Storage.layout();\n        store._allTokensIndex[tokenId] = store._allTokens.length;\n        store._allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = balanceOf(from);\n        ERC721Storage.Layout storage store = ERC721Storage.layout();\n        uint256 tokenIndex = store._ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = store._ownedTokens[from][lastTokenIndex];\n\n            store._ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            store._ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete store._ownedTokensIndex[tokenId];\n        delete store._ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n        ERC721Storage.Layout storage store = ERC721Storage.layout();\n\n        uint256 lastTokenIndex = store._allTokens.length - 1;\n        uint256 tokenIndex = store._allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = store._allTokens[lastTokenIndex];\n\n        store._allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        store._allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete store._allTokensIndex[tokenId];\n        store._allTokens.pop();\n    }\n\n    /**\n     * See {ERC721-_increaseBalance}. We need that to account tokens that were minted in batch\n     */\n    function _increaseBalance(address account, uint128 amount) internal override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }\n}\n"
    },
    "contracts/tokens/RAIR-721/Facets/ERC721Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.25;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {IERC165, ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {IERC721Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {ERC721Storage} from \"../AppStorage.sol\";\nimport {ERC721AccessControlRoles} from \"../AccessControlRoles.sol\";\nimport {AccessControlEnumerable} from \"../../../common/DiamondStorage/AccessControlEnumerable.sol\";\n\ninterface IRAIR721 {\n    /// @notice This event stores in the blockchain when a product is succesfully finished\n    /// @param  productIndex Contains the position where the product was indexed\n\tevent ProductCompleted(uint indexed productIndex);\n\t/// @notice This event stores in the blockchain when a range is succesfully established\n    /// @param  rangeIndex Contains the position where the range was indexed \n\t/// @param  productIndex Contains the indexed location for the product\n\tevent RangeCompleted(uint indexed rangeIndex, uint productIndex);\n\t/// @notice This event stores in the blockchain when a trading is unlocked\n\t/// @param  rangeIndex Contains the position where the range is indexed\n    /// @param  from Containt the date of begining of the range\n\t/// @param  to Contain the date of end for the range\n\tevent TradingUnlocked(uint indexed rangeIndex, uint from, uint to);\n}\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\n/**\n * @dev Copy of OpenZeppelin's contract using diamond storage\n */\nabstract contract ERC721Facet is\n    Context,\n    ERC165,\n    IERC721,\n    IERC721Metadata,\n    IERC721Errors,\n    ERC721AccessControlRoles,\n    IRAIR721,\n    AccessControlEnumerable\n{\n    using Strings for uint256;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        ERC721Storage.Layout storage store = ERC721Storage.layout();\n        return store._balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        ERC721Storage.Layout storage store = ERC721Storage.layout();\n        return store._name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage.Layout storage store = ERC721Storage.layout();\n        return store._symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage.Layout storage store = ERC721Storage.layout();\n        return store._operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage.Layout storage store = ERC721Storage.layout();\n        return store._owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage.Layout storage store = ERC721Storage.layout();\n        return store._tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if `spender` does not have approval from the provided `owner` for the given token or for all its assets\n     * the `spender` for the specific `tokenId`.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage.Layout storage store = ERC721Storage.layout();\n        unchecked {\n            store._balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        ERC721Storage.Layout storage store = ERC721Storage.layout();\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                store._balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                store._balances[to] += 1;\n            }\n        }\n\n        store._owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        ERC721Storage.Layout storage store = ERC721Storage.layout();\n        store._tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        ERC721Storage.Layout storage store = ERC721Storage.layout();\n        store._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the\n     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    // Custom RAIR functions are included here\n    /// @notice Returns the next token available for minting in a range\n\t/// @param \trangeIndex \tIndex of the range to check\n\t/// @return index \t\tIndex of the next available token\n\tfunction nextMintableTokenInRange(uint rangeIndex) public view returns (uint index) {\n        ERC721Storage.Layout storage store = ERC721Storage.layout();\n\t\trequire(store.ranges.length > rangeIndex, \"RAIR ERC721 Ranges: Range does not exist\");\n\t\tERC721Storage.range memory selectedRange = store.ranges[rangeIndex];\n\t\tERC721Storage.product memory selectedProduct = store.products[store.rangeToProduct[rangeIndex]];\n\t\tfor (index = selectedRange.rangeStart; index < selectedRange.rangeEnd; index++) {\n\t\t\tif (_ownerOf(selectedProduct.startingToken + index) == address(0)) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t}\n\t\trequire(false, 'RAIR ERC721: There are no tokens available for minting');\n\t}\n\n    /// @notice This function allow us to mint a token form a specific range\n\t/// @param to \t\t\tRecipient of the minted token\n\t/// @param rangeId\t\tIndex of the range from where to mint the token from\n\t/// @param indexInRange\tIndex of the token to mint within the range\n\tfunction _mintFromRange(address to, uint rangeId, uint indexInRange) internal {\n        ERC721Storage.Layout storage store = ERC721Storage.layout();\n\t\trequire(store.ranges.length > rangeId, \"RAIR ERC721: Range does not exist\");\n\t\tERC721Storage.range storage selectedRange = store.ranges[rangeId];\n\t\tERC721Storage.product storage selectedProduct = store.products[store.rangeToProduct[rangeId]];\n\t\trequire(selectedProduct.mintableTokens > 0, 'RAIR ERC721: Cannot mint more tokens from this product!');\n\t\trequire(selectedRange.mintableTokens > 0, 'RAIR ERC721: Cannot mint more tokens from this range!');\n\t\trequire(selectedRange.tokensAllowed > 0, 'RAIR ERC721: Not allowed to mint more tokens from this range!');\n\t\trequire(indexInRange >= selectedRange.rangeStart && indexInRange <= selectedRange.rangeEnd, \"RAIR ERC721: Invalid token index\");\n\t\t_safeMint(to, selectedProduct.startingToken + indexInRange, '');\n\t\t\n\t\tif (selectedRange.tokensAllowed > 0) {\n\t\t\tselectedRange.tokensAllowed--;\n\t\t}\n\t\tif (selectedRange.mintableTokens > 0) {\n\t\t\tselectedRange.mintableTokens--;\n\t\t\tif (selectedRange.mintableTokens == 0) {\n\t\t\t\temit RangeCompleted(rangeId, store.rangeToProduct[rangeId]);\n\t\t\t}\n\t\t}\n\t\tif (selectedRange.lockedTokens > 0) {\n\t\t\tselectedRange.lockedTokens--;\n\t\t\tif (selectedRange.lockedTokens == 0) {\n\t\t\t\temit TradingUnlocked(rangeId, selectedRange.rangeStart, selectedRange.rangeEnd);\n\t\t\t}\n\t\t}\n\t\tif (selectedProduct.mintableTokens > 0) {\n\t\t\tselectedProduct.mintableTokens--;\n\t\t\tif (selectedProduct.mintableTokens == 0) {\n\t\t\t\temit ProductCompleted(store.rangeToProduct[rangeId]);\n\t\t\t}\n\t\t}\n\t\tstore.tokenToProduct[selectedProduct.startingToken + indexInRange] = store.rangeToProduct[rangeId];\n\t\tstore.tokenToRange[selectedProduct.startingToken + indexInRange] = rangeId;\n\t\tstore.tokensByProduct[store.rangeToProduct[rangeId]].push(selectedProduct.startingToken + indexInRange);\n\t}\n\n    /// @notice This function allow us to mint a token form a batch of ranges\n\t/// @param to Contains the address that will own the minted token\n\t/// @param rangeId Contains the id of the range that we want to use for minting \n\t/// @param indexInRange Contains array of ranges that will be used to index the minted NFT\n\tfunction mintFromRangeBatch(\n\t\taddress[] calldata to,\n\t\tuint rangeId,\n\t\tuint[] calldata indexInRange\n\t) external onlyRole(MINTER) {\n\t\trequire(to.length > 0, \"RAIR ERC721: Empty array\");\n\t\trequire(to.length == indexInRange.length, \"RAIR ERC721: Both arrays should have the same length\");\n\t\tfor (uint i = 0; i < to.length; i++) {\n\t\t\t_mintFromRange(to[i], rangeId, indexInRange[i]);\n\t\t}\n\t}\n\n    /// @notice External function to mint from a range\n\t///\t@dev\tOnly a contract with the `MINTER` role is available to use this function\n\t/// @param to \t\t\tRecipient of the token\n\t/// @param rangeId \t\tRange to mint from\n\t/// @param indexInRange Index of the token to mint\n\tfunction mintFromRange(address to, uint rangeId, uint indexInRange) external onlyRole(MINTER) {\n\t\t_mintFromRange(to, rangeId, indexInRange);\n\t}\n}\n"
    },
    "contracts/tokens/RAIR-721/Facets/ProductFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25;\n\nimport {ERC721Storage} from \"../AppStorage.sol\";\nimport {ERC721AccessControlRoles} from \"../AccessControlRoles.sol\";\nimport {AccessControlEnumerable} from \"../../../common/DiamondStorage/AccessControlEnumerable.sol\";\n\n/// @title  RAIR Product facet contract\n/// @notice Facets for Product management\ncontract RAIRProductFacet is AccessControlEnumerable, ERC721AccessControlRoles {\n    /// @param  collectionIndex \tIndex for the collection\n\t/// @param  collectionName \t\tName for the collection\n\t/// @param  startingToken \t\tFirst token in the collection (include)\n\t/// @param  collectionLength \tNumber of tokens in the collection\n\tevent CreatedCollection(uint indexed collectionIndex, string collectionName, uint startingToken, uint collectionLength);\n\n\t/// @notice Verifies that the product exists\n\t/// @param\tcollectionId\tCollection to verify\n\tmodifier collectionExists(uint collectionId) {\n\t\trequire(ERC721Storage.layout().products.length > collectionId, \"RAIR ERC721: Collection does not exist\");\n\t\t_;\n\t}\n\n\t/// @notice Verifies that the range exists\n\t/// @param\trangeID\tRange to verify\n\tmodifier rangeExists(uint rangeID) {\n\t\trequire(ERC721Storage.layout().ranges.length > rangeID, \"RAIR ERC721: Range does not exist\");\n\t\t_;\n\t}\n\n\t/// @notice Verifies that the token exists\n\t/// @param\ttokenIndex\tRange to verify\n\tmodifier tokenExists(uint tokenIndex) {\n\t\trequire(\n\t\t\tERC721Storage.layout()._owners[tokenIndex] != address(0),\n\t\t\t\"RAIR ERC721: Query for nonexistent token\"\n\t\t);\n\t\t_;\n\t}\n\n\t/// @notice Wrapper for the validator, searching for the entire product\n\t/// @dev \tThis function require that the product exist\n\t/// @param\tfind\t\t\tAddress to search\n\t/// @param\tproductIndex\tCollection to verify\n\t/// @return bool \t\t\tFor the existence or not, of the token in the product \n\tfunction ownsTokenInProduct(address find, uint productIndex) public view collectionExists(productIndex) returns (bool) {\n\t\tERC721Storage.product storage selectedProduct = ERC721Storage.layout().products[productIndex];\n\t\treturn _ownsTokenInsideRange(find, selectedProduct.startingToken, selectedProduct.endingToken);\n\t}\n\n\t/// @notice Wrapper for the validator, searching for the entire range\n\t/// @dev \tThis function require that the range exist \n\t/// @param\tfind\t\tAddress to search\n\t/// @param\trangeIndex\tRange to verify\n\t/// @return bool \t\tFor the existence or not, of the token in the range \n\tfunction ownsTokenInRange(address find, uint rangeIndex) public view rangeExists(rangeIndex) returns (bool) {\n\t\tERC721Storage.Layout storage store = ERC721Storage.layout();\n\t\tERC721Storage.range storage selectedRange = store.ranges[rangeIndex];\n\t\tuint startOfProduct = store.products[store.rangeToProduct[rangeIndex]].startingToken;\n\t\treturn _ownsTokenInsideRange(find, startOfProduct + selectedRange.rangeStart, startOfProduct + selectedRange.rangeEnd);\n\t}\n\n\t/// @notice Validates that an address owns at least one token inside a specified range\n\t/// @dev Loops through the range, don't use on non-view functions\n\t/// @param\tfind\tAddress to validate\n\t/// @param\tfrom\tRange start\n\t/// @param\tto\t\tRange end\n\t/// @return bool \tFor the existence or not, of the token inside the range \n\tfunction _ownsTokenInsideRange(address find, uint from, uint to) internal view returns (bool) {\n\t\tfor (uint i = from; i < to; i++) {\n\t\t\tif (ERC721Storage.layout()._owners[i] == find) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/// @notice This function allow us to see the position of creation of a token\n\t/// @dev \tThis function require that the collection exist\n\t/// @param \tproductIndex_ Contains the index of the collection where is the token\n\t/// @param \ttokenIndex_   Contains the index of the token inside the collection\n\t/// @return uint\t\t  With the value of the token in that indexed position \n\tfunction tokenByProduct(uint productIndex_, uint tokenIndex_) public view collectionExists(productIndex_) returns (uint) {\n\t\treturn ERC721Storage.layout().tokensByProduct[productIndex_][tokenIndex_];\n\t}\n\n\t/// @notice This function will search in a collection for a especific token and return its value\n\t/// @dev \tThis function require that the collection exist\\\n\t/// @param \tproductIndex_ Contains the index of the collection where is the token\n\t/// @param \ttokenIndex_   Contains the index of the token inside the collection\n\t/// @return uint\t\t  With the value of the token in that indexed position \n\tfunction productToToken(uint productIndex_, uint tokenIndex_) public view collectionExists(productIndex_) returns(uint) {\n\t\treturn ERC721Storage.layout().products[productIndex_].startingToken + tokenIndex_;\n\t}\n\n\t/// @notice This function allow us to know the index of the collection that contains the token\n\t/// @dev \tThis function require that the token exist\n\t/// @param  tokenIndex_  Contains the index of the token inside the collection\n\t/// @return uint \t\t Return the ID of the collection \n\tfunction tokenToProductIndex(uint tokenIndex_) public view tokenExists(tokenIndex_) returns (uint) {\n\t\tERC721Storage.Layout storage store = ERC721Storage.layout();\n\t\treturn tokenIndex_ - store.products[store.tokenToProduct[tokenIndex_]].startingToken;\n\t}\n\n\t/// @notice This function allow us to locaste the collection & range of a token \n\t/// @dev \tThis function require that the token exist\n\t/// @param \ttokenIndex_   Contains the index of the token which info we want to know \n\t/// @return productIndex  With the corresponding collection ID for the token\n\t/// @return rangeIndex\t  With the corresponding range of the collection \n\tfunction tokenToProduct(uint tokenIndex_) public view tokenExists(tokenIndex_) returns (uint productIndex, uint rangeIndex) {\n\t\tERC721Storage.Layout storage store = ERC721Storage.layout();\n\t\tproductIndex = store.tokenToProduct[tokenIndex_];\n\t\trangeIndex = store.tokenToRange[tokenIndex_];\n\t}\n\n\t/// @notice\tReturns the number of products on the contract\n\t/// @dev\tUse with get product to list all of the products\n\t/// @return uint With the total of products\n\tfunction getProductCount() external view returns(uint) {\n\t\treturn ERC721Storage.layout().products.length;\n\t}\n\n\t/// @notice This function allow us to check the information of a product\n\t/// @dev \tThis function require that the collection exist\n\t/// @param productIndex_ Contains the id of the product that we want to verify\n\t/// @return product which contain the information of the product\n\tfunction getProductInfo(uint productIndex_)\n\t\texternal\n\t\tview\n\tcollectionExists(productIndex_) returns (ERC721Storage.product memory) {\n\t\treturn ERC721Storage.layout().products[productIndex_];\n\t}\n\n\t/// @notice This functions allow us to check is a token is owned by an account\n\t/// @param owner Contains address of the acount that we want to verify\n\t/// @param index Contains the position in the owned tokens list\n\t/// @return uint with the token that is owned by the account in that position \n\tfunction tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n\t\trequire(index < RAIRProductFacet.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n\t\treturn ERC721Storage.layout()._ownedTokens[owner][index];\n\t}\n\n\t/// @notice this funtions allow us to know the balance of an account\n\t/// @param owner Contains the address which balance we want to verify\n\t/// @return uint256 with the current balance of the account\n\tfunction balanceOf(address owner) public view returns (uint256) {\n\t\trequire(owner != address(0), \"ERC721: balance query for the zero address\");\n\t\treturn ERC721Storage.layout()._balances[owner];\n\t}\n\n\t/// @notice \t\tCheck if the NFT has an owner\n\t/// @param tokenId \tNFT id to check\n\t/// @return bool \tto indicate if the token exist or not\n\tfunction _exists(uint256 tokenId) internal view returns (bool) {\n        return ERC721Storage.layout()._owners[tokenId] != address(0);\n    }\n\t\n\t/// @notice\tLoops through a range of tokens inside a collection and returns the first token without an owner\n\t/// @dev\tUses a loop, do not call this from a non-view function!\n\t/// @dev \tThis functions require that the collection exist to properly work \n\t/// @param\tcollectionId\tIndex of the collection that we want to loop\n\t/// @param\tstartingIndex\tIndex of the starting token of the product\n\t/// @param\tendingIndex\t\tIndex of the last token of the product \n\t/// @return nextIndex\t\tWith the next starting point available for new products\n\tfunction getNextSequentialIndex(uint collectionId, uint startingIndex, uint endingIndex) public view collectionExists(collectionId) returns(uint nextIndex) {\n\t\tERC721Storage.product memory currentProduct = ERC721Storage.layout().products[collectionId];\n\t\tfor (uint i = currentProduct.startingToken + startingIndex; i <= currentProduct.startingToken + endingIndex; i++) {\n\t\t\tif (!_exists(i)) {\n\t\t\t\treturn i - currentProduct.startingToken;\n\t\t\t}\n\t\t}\n\t\trequire(false, \"RAIR ERC721: There are no available tokens in this range.\");\n\t}\n\n\t/// @notice\tLoops over the user's tokens looking for one that belongs to a product and a specific range\n\t/// @dev\tLoops are expensive in solidity, so don't use this in a function that requires gas\n\t/// @param\tuserAddress\t\t\tAddress that will be uses to see the belonging tokens of a product and a range\n\t/// @param\tproductIndex\t\tIndex of the collection to search\n\t/// @param\tstartingToken\t\tStarting token to search\n\t/// @param\tendingToken\t\t\tLast token to search \n\t/// @return bool \t\t\t\tWhich respond if the tokens belongs or not to a product and a range\n\tfunction hasTokenInProduct(\n\t\t\t\taddress userAddress,\n\t\t\t\tuint productIndex,\n\t\t\t\tuint startingToken,\n\t\t\t\tuint endingToken) public view returns (bool) {\n\t\tERC721Storage.Layout storage store = ERC721Storage.layout();\n\t\tERC721Storage.product memory aux = store.products[productIndex];\n\t\tif (aux.endingToken != 0) {\n\t\t\tfor (uint i = 0; i < balanceOf(userAddress); i++) {\n\t\t\t\tuint token = tokenOfOwnerByIndex(userAddress, i);\n\t\t\t\tif (store.tokenToProduct[token] == productIndex &&\n\t\t\t\t\t\ttoken >= aux.startingToken + startingToken &&\n\t\t\t\t\t\ttoken <= aux.startingToken + endingToken) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/// @notice\tReturns the number of tokens inside a product\n\t/// @param\tproductIndex \tProduct index to verify\n\t/// @return length  \t \tNumber of tokens already minted\n\tfunction mintedTokensInProduct(uint productIndex) public view returns (uint length) {\n\t\tlength = ERC721Storage.layout().tokensByProduct[productIndex].length;\n\t}\n\t\n\t/// @notice\tCreates a new product\n\t/// @dev \tThis function is only available to an account with a `CREATOR` role\n\t/// @param\t_productName \tName of the product to create\n\t/// @param\t_copies\t\t\tAmount of tokens inside the product\n\tfunction createProduct(string memory _productName, uint _copies) public onlyRole(CREATOR) {\n\t\tERC721Storage.Layout storage store = ERC721Storage.layout();\n\t\tuint lastToken = store.products.length == 0 ? 0 : store.products[store.products.length - 1].endingToken + 1;\n\t\t\n\t\tERC721Storage.product storage newProduct = store.products.push();\n\n\t\tnewProduct.startingToken = lastToken;\n\t\tnewProduct.endingToken = newProduct.startingToken + _copies - 1;\n\t\tnewProduct.name = string(_productName);\n\t\tnewProduct.mintableTokens = _copies;\n\t\t\n\t\temit CreatedCollection(store.products.length - 1, _productName, lastToken, _copies);\n\t}\n}"
    },
    "contracts/tokens/RAIR-721/Facets/RAIRMetadataFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25;\n\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {ERC721Storage} from \"../AppStorage.sol\";\nimport {ERC721AccessControlRoles} from \"../AccessControlRoles.sol\";\nimport {AccessControlEnumerable} from \"../../../common/DiamondStorage/AccessControlEnumerable.sol\";\n\n/// @title  RAIR Metadata facet contract\n/// @notice You can use this contract to administrate the metadata asociated to the Rair facet\n/// @author Juan M. Sanchez M.\n/// @dev \tNotice that this contract is inheriting from AccessControlAppStorageEnumerable721\ncontract RAIRMetadataFacet is ERC721AccessControlRoles, AccessControlEnumerable {\n\tusing Strings for uint256;\n\n\t/// @notice This event stores in the blockchain when the base code of all the tokens has an update in its URI\n    /// @param  newURI \t\t\t\tContains the new  base identifier for all the tokens\n\t/// @param  appendTokenIndex \tContains the index of the tokens appended to the URI\n\t/// @param \tmetadataExtension \tFile extension (if exists)\n\tevent UpdatedBaseURI(string newURI, bool appendTokenIndex, string metadataExtension);\n\t/// @notice This event stores in the blockchain when a token has a change in its URI\n\t/// @param  tokenId \t\t\tContains the index of the token appended to the URI\n    /// @param  newURI \t\t\t\tContains the new identifier for the token\n\tevent UpdatedTokenURI(uint tokenId, string newURI);\n\t/// @notice This event stores in the blockchain when a product has a change in its URI\n\t/// @param \tproductId \t\t\tContains the index of the product to change\n    /// @param  newURI \t\t\t\tContains the new identifier for the product\n\t/// @param  appendTokenIndex \tContains the index of the token appended to the URI\n\t/// @param \tmetadataExtension \tFile extension (if exists)\n\tevent UpdatedProductURI(uint productId, string newURI, bool appendTokenIndex, string metadataExtension);\n\t/// @notice This event stores in the blockchain when a range has a change in its URI\n\t/// @param \trangeId \t\t\tContains the index of the product to change\n    /// @param  newURI \t\t\t\tContains the new identifier for the product\n\t/// @param  appendTokenIndex \tContains the index of the token appended to the URI\n\t/// @param \tmetadataExtension \tFile extension (if exists)\n\tevent UpdatedRangeURI(uint rangeId, string newURI, bool appendTokenIndex, string metadataExtension);\n\t/// @notice This event stores in the blockchain when a contract has a change in its URI\n    /// @param  newURI \t\t\t\tContains the new identifier for the contract \n\tevent UpdatedContractURI(string newURI);\n\t/// @notice This event informs the new extension all metadata URIs will have appended at the end\n\t/// @dev \tIt will be appended ONLY if the token ID has to also be appended\n\t/// @param \tnewExtension The new extension for all the URIs\n    event UpdatedURIExtension(string newExtension);\n\n\n\t// For OpenSea's Freezing\n\tevent PermanentURI(string _value, uint256 indexed _id);\n\n\t/// @notice This function allows us to check if the token exist or not\n\t/// @param\ttokenId\tContains the index of the token that we want to verify \n\t/// @return bool Answer true if the token exist or false if not \n\tfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\n\t\treturn ERC721Storage.layout()._owners[tokenId] != address(0);\n\t}\n\n\t/// @notice\tReturns the token index inside the product\n\t/// @param\ttoken\tToken ID to find\n\t/// @return tokenIndex which contains the corresponding token index\n\tfunction tokenToCollectionIndex(uint token) public view returns (uint tokenIndex) {\n\t\tERC721Storage.Layout storage store = ERC721Storage.layout();\n\t\treturn token - store.products[store.tokenToProduct[token]].startingToken;\n\t}\n\n\t/// @notice\tUpdates the unique URI of all the tokens, but in a single transaction\n\t/// @dev \tThis function is only available to an account with a `CREATOR` role\n\t/// @dev\tUses the single function so it also emits an event\n\t/// @dev \tThis function requires that all the tokens have a corresponding URI\n\t/// @param\ttokenIds\tToken Indexes that will be given an URI\n\t/// @param\tnewURIs\t\tNew URIs to be set\n\tfunction setUniqueURIBatch(uint[] calldata tokenIds, string[] calldata newURIs) external onlyRole(CREATOR) {\n\t\trequire(\n\t\t\ttokenIds.length == newURIs.length,\n\t\t\t\"RAIR ERC721: Token IDs and URIs should have the same length\"\n\t\t);\n\t\tfor (uint i = 0; i < tokenIds.length; i++) {\n\t\t\tsetUniqueURI(tokenIds[i], newURIs[i]);\n\t\t}\n\t}\n\t\n\t/// @notice\tGives an individual token an unique URI\n\t/// @dev \tThis function is only available to an account with a `CREATOR` role\n\t/// @dev\tEmits an event so there's provenance\n\t/// @param\ttokenId\tToken Index that will be given an URI\n\t/// @param\tnewURI\tNew URI to be given\n\tfunction setUniqueURI(uint tokenId, string calldata newURI) public onlyRole(CREATOR) {\n\t\tERC721Storage.Layout storage store = ERC721Storage.layout();\n\t\tstore.uniqueTokenURI[tokenId] = newURI;\n\t\temit UpdatedTokenURI(tokenId, newURI);\n\t}\n\n\t/// @notice  Updates the metadata extension added at the end of all tokens\n    /// @dev     Must include the . before the extension\n    /// @param extension     Extension to be added at the end of all contract wide tokens\n    function setMetadataExtension(string calldata extension) external onlyRole(CREATOR) {\n        require(\n\t\t\tbytes(extension)[0] == '.',\n\t\t\t\"RAIR ERC721: Extension must start with a '.'\"\n\t\t);\n\t\tERC721Storage.Layout storage store = ERC721Storage.layout();\n        store._metadataExtension = extension;\n        emit UpdatedURIExtension(store._metadataExtension);\n    }\n\n\t/// @notice\tGives all tokens within a range a specific URI\n    /// @dev\tEmits an event so there's provenance\n    /// @param\trangeId\t\t\t\tToken Index that will be given an URI\n    /// @param\tnewURI\t\t    \tNew URI to be given\n    /// @param\tappendTokenIndex\tFlag to append the token index at the end of the new URI\n    function setRangeURI(\n        uint rangeId,\n        string calldata newURI,\n        bool appendTokenIndex\n    ) public onlyRole(CREATOR) {\n\t\tERC721Storage.Layout storage store = ERC721Storage.layout();\n        store.rangeURI[rangeId] = newURI;\n        store.appendTokenIndexToRangeURI[rangeId] = appendTokenIndex;\n        emit UpdatedRangeURI(rangeId, newURI, appendTokenIndex, store._metadataExtension);\n    }\n\n\t/// @notice\tGives an individual token an unique URI\n\t/// @dev \tThis function is only available to an account with a `CREATOR` role\n\t/// @dev\tEmits an event so there's provenance\n\t/// @param\tproductId\t\t\t\t\t\tToken Index that will be given an URI\n\t/// @param\tnewURI\t\t\t\t\t\t\tNew URI to be given\n\t/// @param\tappendTokenIndexToProductURI \tIf true, it will append the token index to the URI\n\tfunction setCollectionURI(uint productId, string calldata newURI, bool appendTokenIndexToProductURI) public onlyRole(CREATOR) {\n\t\tERC721Storage.Layout storage store = ERC721Storage.layout();\n\t\tstore.productURI[productId] = newURI;\n\t\tstore.appendTokenIndexToProductURI[productId] = appendTokenIndexToProductURI;\n\t\temit UpdatedProductURI(\n\t\t\tproductId,\n\t\t\tnewURI,\n\t\t\tappendTokenIndexToProductURI,\n\t\t\tstore._metadataExtension\n\t\t);\n\t}\n\n\t/// @notice\tThis function use OpenSea's to freeze the metadata\n\t/// @dev \tThis function is only available to an account with a `CREATOR` role\n\t/// @param tokenId Token Index that will be given an URI\n\tfunction freezeMetadata(uint tokenId) public onlyRole(CREATOR) {\n\t\temit PermanentURI(tokenURI(tokenId), tokenId);\n\t}\n\n\t/// @notice\tThis function allow us to set a new contract URI\n\t/// @dev \tThis function is only available to an account with a `CREATOR` role\n\t/// @param newURI New URI to be given\n\tfunction setContractURI(string calldata newURI) external onlyRole(CREATOR) {\n\t\tERC721Storage.Layout storage store = ERC721Storage.layout();\n\t\tstore.contractMetadataURI = newURI;\n\t\temit UpdatedContractURI(newURI);\n\t}\n\n\t/// @notice\tThis function allow us to see the current URI of the contract\n\t/// @return string with the URI of the contract \n\tfunction contractURI() public view returns (string memory) {\n\t\treturn ERC721Storage.layout().contractMetadataURI;\n\t}\n\t\n\t/// @notice\tSets the Base URI for ALL tokens\n\t/// @dev \tThis function is only available to an account with a `CREATOR` role\n\t/// @dev\tCan be overriden by the specific token URI\n\t/// @param\tnewURI\tURI to be used\n\t/// @param\tappendTokenIndexToBaseURI\tURI to be used\n\tfunction setBaseURI(string calldata newURI, bool appendTokenIndexToBaseURI) external onlyRole(CREATOR) {\n\t\tERC721Storage.Layout storage store = ERC721Storage.layout();\n\t\tstore.baseURI = newURI;\n\t\tstore.appendTokenIndexToBaseURI = appendTokenIndexToBaseURI;\n\t\temit UpdatedBaseURI(newURI, appendTokenIndexToBaseURI, store._metadataExtension);\n\t}\n\n\t/// @notice\tReturns a token's URI\n    /// @dev\tWill return unique token URI or product URI or contract URI\n    /// @param\ttokenId\t\tToken Index to look for\n\t/// @return string with the URI of the toke that we are using\n    function tokenURI(uint tokenId)\n        public\n        view\n        returns (string memory)\n    {\n\t\tERC721Storage.Layout storage store = ERC721Storage.layout();\n        // Unique token URI\n        string memory URI = store.uniqueTokenURI[tokenId];\n        if (bytes(URI).length > 0) {\n            return URI;\n        }\n\n        // Range wide URI\n        URI = store.rangeURI[store.tokenToRange[tokenId]];\n        if (bytes(URI).length > 0) {\n            if (store.appendTokenIndexToRangeURI[store.tokenToRange[tokenId]]) {\n                return\n\t\t\t\t\tstring.concat(\n\t\t\t\t\t\tURI,\n\t\t\t\t\t\ttokenToCollectionIndex(tokenId).toString(),\n\t\t\t\t\t\tstore._metadataExtension\n                    );\n            }\n            return URI;\n        }\n\n        // Collection wide URI\n        URI = store.productURI[store.tokenToProduct[tokenId]];\n        if (bytes(URI).length > 0) {\n            if (store.appendTokenIndexToProductURI[store.tokenToProduct[tokenId]]) {\n                return\n                    string.concat(\n\t\t\t\t\t\tURI,\n\t\t\t\t\t\ttokenToCollectionIndex(tokenId).toString(),\n\t\t\t\t\t\tstore._metadataExtension\n                    );\n            }\n            return URI;\n        }\n\n        URI = store.baseURI;\n        if (store.appendTokenIndexToBaseURI) {\n            return\n                string.concat(\n\t\t\t\t\tURI,\n\t\t\t\t\ttokenId.toString(),\n\t\t\t\t\tstore._metadataExtension\n                );\n        }\n        return URI;\n    }\n}"
    },
    "contracts/tokens/RAIR-721/Facets/RangesFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25;\n\nimport {ERC721Storage} from \"../AppStorage.sol\";\nimport {ERC721AccessControlRoles} from \"../AccessControlRoles.sol\";\nimport {AccessControlEnumerable} from \"../../../common/DiamondStorage/AccessControlEnumerable.sol\";\n\n/// @title  This is contract to manage the Rair token ranges facet\n/// @notice You can use this contract to administrate ranges, transfers & minting of the tokens\n/// @author Juan M. Sanchez M.\n/// @dev \tNotice that this contract is inheriting from AccessControlAppStorageEnumerable721\ncontract RAIRRangesFacet is AccessControlEnumerable, ERC721AccessControlRoles {\n\t/// @notice This event stores in the blockchain when the NFT range is correctly created\n    /// @param  productIndex Contains the position where the product was indexed\n\t/// @param  start Contains the start position of the range of nft collection\n\t/// @param  end Contains the last NFT of the range collection\n\t/// @param  price Contains the selling price for the range of NFT\n\t/// @param  tokensAllowed Contains all the allowed NFT tokens in the range that are available for sell\n\t/// @param  lockedTokens Contains all the NFT tokens in the range that are unavailable for sell\n\t/// @param  name Contains the name for the created NFT collection range\n\t/// @param  rangeIndex Contains the position where the range was indexed\n\tevent CreatedRange(uint productIndex, uint start, uint end, uint price, uint tokensAllowed, uint lockedTokens, string name, uint rangeIndex);\n\t/// @notice This event stores in the blockchain when the NFT range is correctly updated\n    /// @param  rangeIndex Contains the position where the range was indexed\n\t/// @param  name Contains the name for the created NFT collection range\n\t/// @param  price Contains the selling price for the range of NFT\n\t/// @param  tokensAllowed Contains all the allowed NFT tokens in the range that are available for sell\n\t/// @param  lockedTokens Contains all the NFT tokens in the range that are unavailable for sell\n\tevent UpdatedRange(uint rangeIndex, string name, uint price, uint tokensAllowed, uint lockedTokens);\n\t/// @notice This event stores in the blockchain when the NFT range trading is effectively locked  \n    /// @param  rangeIndex Contains the position where the range was indexed\n\t/// @param  from Contains the starting NFT of the range that we want to lock\n\t/// @param  to Contains the last NFT of the range that we want to lock\n\t/// @param  lockedTokens Contains all the NFT tokens in the range that are unavailable for sell\n\tevent TradingLocked(uint indexed rangeIndex, uint from, uint to, uint lockedTokens);\n\t/// @notice This event stores in the blockchain when the NFT range trading is effectively unlocked \n    /// @param  rangeIndex Contains the position where the range was indexed\n\t/// @param  from Contains the starting NFT of the range that we want to lock\n\t/// @param  to Contains the last NFT of the range that we want to lock\n\tevent TradingUnlocked(uint indexed rangeIndex, uint from, uint to);\n\n\t// Auxiliary struct used to avoid Stack too deep errors\n\tstruct rangeData {\n\t\tuint rangeLength;\n\t\tuint price;\n\t\tuint tokensAllowed;\n\t\tuint lockedTokens;\n\t\tstring name;\n\t}\n\n\t/// @notice Verifies that the range exists\n\t/// @param\trangeID\tIdentification of the range to verify\n\tmodifier rangeExists(uint rangeID) {\n\t\trequire(ERC721Storage.layout().ranges.length > rangeID, \"RAIR ERC721 Ranges: Range does not exist\");\n\t\t_;\n\t}\n\n\t/// @notice This functions verify if the current colecction exist or not\n\t/// @param\tcollectionId\tIdentification of the collection that we want to use\n\tmodifier collectionExists(uint collectionId) {\n\t\trequire(ERC721Storage.layout().products.length > collectionId, \"RAIR ERC721 Ranges: Collection does not exist\");\n\t\t_;\n\t}\n\n\t/// @notice This functions return us the product that containt the selected range\n\t/// @dev \tThis function requires that the rangeIndex_ points to an existing range \n\t/// @param\trangeIndex_\t\tIdentification of the range to verify\n\t/// @return uint which indicates the index of the product\n\tfunction rangeToProduct(uint rangeIndex_) public view rangeExists(rangeIndex_) returns (uint) {\n\t\treturn ERC721Storage.layout().rangeToProduct[rangeIndex_];\n\t}\n\n\t/// @notice This functions allow us to check the information of the range\n\t/// @dev \tThis function requires that the rangeIndex_ points to an existing range \n\t/// @param\trangeId\tIdentification of the range to verify\n\t/// @return data \t\t\tInformation about the range\n\t/// @return productIndex \tContains the index of the product in the range\n\tfunction rangeInfo(uint rangeId) external view rangeExists(rangeId) returns(ERC721Storage.range memory data, uint productIndex) {\n\t\tERC721Storage.Layout storage store = ERC721Storage.layout();\n\t\tdata = store.ranges[rangeId];\n\t\tproductIndex = store.rangeToProduct[rangeId];\n\t}\n\n\t/// @notice This functions shows is the range is currently locked or not \n\t/// @dev \tThis function requires that the rangeIndex_ points to an existing range \n\t/// @param\trangeId\tIdentification of the range to verify\n\t/// @return bool with the current status of the range lock\n\t///\t\t\ttrue for lock and false for unlocked\n\tfunction isRangeLocked(uint rangeId) external view rangeExists(rangeId) returns (bool) {\n\t\treturn ERC721Storage.layout().ranges[rangeId].lockedTokens > 0;\n\t}\n\n\t/// @notice This functions shows the information for the range of a product\n\t/// @param\tcollectionId\tIndex of the product to verify\n\t/// @param\trangeIndex\t\tIndex of the range to verify\n\t/// @return data \t\t\tInformation about the range\n\tfunction productRangeInfo(uint collectionId, uint rangeIndex)\n\t\texternal\n\t\tview\n\t\tcollectionExists(collectionId)\n\t\treturns(ERC721Storage.range memory data)\n\t{\n\t\tERC721Storage.Layout storage store = ERC721Storage.layout();\n\t\trequire(\n\t\t\tstore.products[collectionId].rangeList.length > rangeIndex,\n\t\t\t\"RAIR ERC721 Ranges: Invalid range index\"\n\t\t);\n\t\tdata = store.ranges[store.products[collectionId].rangeList[rangeIndex]];\n\t}\n\n\t/// @notice This functions allow us to update the information about a range\n\t/// @dev \tThis function requires that the rangeIndex_ points to an existing range\n\t/// @dev \tThis function is only available to an account with a `CREATOR` role\n\t/// @param\trangeId\t\t\tIdentification of the range to verify\n\t/// @param\tname\t\t\tContains the name for the created NFT collection range\n\t/// @param\tprice_\t\t\tContains the selling price for the range of NFT\n\t/// @param\ttokensAllowed_\tContains all the allowed NFT tokens in the range that are available for sell\n\t/// @param\tlockedTokens_\tContains all the NFT tokens in the range that are unavailable for sell\n\tfunction updateRange(\n\t\tuint rangeId,\n\t\tstring memory name,\n\t\tuint price_,\n\t\tuint tokensAllowed_,\n\t\tuint lockedTokens_\n\t) public rangeExists(rangeId) onlyRole(CREATOR) {\n\t\trequire(\n\t\t\tprice_ == 0 || price_ >= 100,\n\t\t\t\"RAIR ERC721: Minimum price allowed is 100 wei\"\n\t\t);\n\t\tERC721Storage.range storage selectedRange = ERC721Storage.layout().ranges[rangeId];\n\t\trequire(\n            tokensAllowed_ <= selectedRange.mintableTokens,\n            \"RAIR ERC721: Allowed tokens should be less than the number of mintable tokens\"\n        );\n        require(\n            lockedTokens_ <= selectedRange.mintableTokens + 1,\n\t\t\t// The +1 allows for permanent lock of the range\n            \"RAIR ERC721: Locked tokens should be less than the number of mintable tokens\"\n        );\n\t\tselectedRange.tokensAllowed = tokensAllowed_;\n\t\tif (lockedTokens_ > 0 && selectedRange.lockedTokens == 0) {\n            emit TradingLocked(\n                rangeId,\n                selectedRange.rangeStart,\n                selectedRange.rangeEnd,\n                lockedTokens_\n            );\n        } else if (lockedTokens_ == 0 && selectedRange.lockedTokens > 0) {\n            emit TradingUnlocked(\n                rangeId,\n                selectedRange.rangeStart,\n                selectedRange.rangeEnd\n            );\n        }\n\t\tselectedRange.lockedTokens = lockedTokens_;\n        selectedRange.rangePrice = price_;\n        selectedRange.rangeName = name;\n\t\temit UpdatedRange(rangeId, name, price_, tokensAllowed_, lockedTokens_);\n\t}\n\n\t/// @notice Checks if the information for the range is valid\n\t/// @param\tproductId_\tId for product\n\t/// @param\trangeStart_\tNFT to start the range with\n\t/// @param\trangeEnd_\tNFT to end the range with\n\t/// @return bool \t\tResponse\n\tfunction canCreateRange(uint productId_, uint rangeStart_, uint rangeEnd_) public view returns (bool) {\n\t\tERC721Storage.Layout storage store = ERC721Storage.layout();\n\t\tuint[] memory rangeList = store.products[productId_].rangeList;\n\t\tfor (uint i = 0; i < rangeList.length; i++) {\n\t\t\tif ((store.ranges[rangeList[i]].rangeStart <= rangeStart_ &&\n\t\t\t\t\tstore.ranges[rangeList[i]].rangeEnd >= rangeStart_) || \n\t\t\t\t(store.ranges[rangeList[i]].rangeStart <= rangeEnd_ &&\n\t\t\t\t\tstore.ranges[rangeList[i]].rangeEnd >= rangeEnd_)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t/// @notice This is a internal function that will create the NFT range if the requirements are meet\n\t/// @param\tproductId_\t\tContains the identification for the product\n\t/// @param\trangeLength_\tNumber of tokens contained in the range\n\t/// @param \tprice_ \t\t\tContains the selling price for the range of NFT\n\t/// @param \ttokensAllowed_ \tContains all the allowed NFT tokens in the range that are available for sell\n\t/// @param \tlockedTokens_ \tContains all the NFT tokens in the range that are unavailable for sell\n\t/// @param \tname_ \t\t\tContains the name for the created NFT collection range\n\tfunction _createRange(\n\t\tuint productId_,\n\t\tuint rangeLength_,\n\t\tuint price_,\n\t\tuint tokensAllowed_,\n\t\tuint lockedTokens_,\n\t\tstring memory name_\n\t) internal {\n\t\t// Sanity checks\n\t\t// 0 to make the offer free, over 100 to make sure paid offers can split the funds correctly\n\t\trequire(price_ == 0 || price_ >= 100, \"RAIR ERC721: Minimum price allowed is 100 wei\");\n\t\trequire(rangeLength_ >= tokensAllowed_, \"RAIR ERC721: Allowed tokens should be less than range's length\");\n\t\trequire(rangeLength_ >= lockedTokens_, \"RAIR ERC721: Locked tokens should be less than range's length\");\n\t\tERC721Storage.Layout storage store = ERC721Storage.layout();\n\t\tERC721Storage.product storage selectedProduct = store.products[productId_];\n\t\tuint lastTokenFromPreviousRange;\n\t\tif (selectedProduct.rangeList.length > 0) {\n\t\t\tlastTokenFromPreviousRange = store.ranges[selectedProduct.rangeList[selectedProduct.rangeList.length - 1]].rangeEnd + 1;\n\t\t}\n\n\t\tERC721Storage.range storage newRange = store.ranges.push();\n\t\tuint rangeIndex = store.ranges.length - 1;\n\n\t\trequire(lastTokenFromPreviousRange + rangeLength_ - 1 <= selectedProduct.endingToken , \"RAIR ERC721: Range length exceeds collection limits!\");\n\n\t\tnewRange.rangeStart = lastTokenFromPreviousRange;\n\t\t// -1 because it includes the starting token\n\t\tnewRange.rangeEnd = lastTokenFromPreviousRange + rangeLength_ - 1;\n\t\tnewRange.tokensAllowed = tokensAllowed_;\n\t\tnewRange.mintableTokens = rangeLength_;\n\t\tnewRange.lockedTokens = lockedTokens_;\n\t\tif (lockedTokens_ > 0) {\n\t\t\temit TradingLocked(rangeIndex, newRange.rangeStart, newRange.rangeEnd, newRange.lockedTokens);\n\t\t} else if (lockedTokens_ == 0) {\n\t\t\temit TradingUnlocked(rangeIndex, newRange.rangeStart, newRange.rangeEnd);\n\t\t}\n\t\tnewRange.rangePrice = price_;\n\t\tnewRange.rangeName = name_;\n\t\tstore.rangeToProduct[rangeIndex] = productId_;\n\t\tselectedProduct.rangeList.push(rangeIndex);\n\n\t\temit CreatedRange(\n\t\t\tproductId_,\n\t\t\tnewRange.rangeStart,\n\t\t\tnewRange.rangeEnd,\n\t\t\tnewRange.rangePrice,\n\t\t\tnewRange.tokensAllowed,\n\t\t\tnewRange.lockedTokens,\n\t\t\tnewRange.rangeName,\n\t\t\trangeIndex\n\t\t);\n\t}\n\n\t/// @notice This function that will create the NFT range if the requirements are meet\n\t/// @dev \tThis function is only available to an account with a `CREATOR` role\n\t/// @dev \tThis function require thar the collection ID match a valid collection \n\t/// @param\tcollectionId\tContains the identification for the product\n\t/// @param\trangeLength\t\tNumber of tokens contained in the range\n\t/// @param \tprice \t\t\tContains the selling price for the range of NFT\n\t/// @param \ttokensAllowed \tContains all the allowed NFT tokens in the range that are available for sell\n\t/// @param \tlockedTokens \tContains all the NFT tokens in the range that are unavailable for sell\n\t/// @param \tname \t\t\tContains the name for the created NFT collection range\n\tfunction createRange(\n\t\tuint collectionId,\n\t\tuint rangeLength,\n\t\tuint price,\n\t\tuint tokensAllowed,\n\t\tuint lockedTokens,\n\t\tstring calldata name\n\t) external onlyRole(CREATOR) collectionExists(collectionId) {\n\t\t_createRange(collectionId, rangeLength, price, tokensAllowed, lockedTokens, name);\n\t}\n\n\t/// @notice This function will create as many ranges as the data array requires\n\t/// @dev \tThis function is only available to an account with a `CREATOR` role\n\t/// @dev \tThis function require thar the collection ID match a valid collection \n\t/// @param\tcollectionId\tContains the identification for the product\n\t/// @param\tdata \t\t\tAn array with the data for all the ranges that we want to implement \n\tfunction createRangeBatch(\n\t\tuint collectionId,\n\t\trangeData[] calldata data\n\t) external onlyRole(CREATOR) collectionExists(collectionId) {\n\t\trequire(data.length > 0, \"RAIR ERC721: Empty array\");\n\t\tfor (uint i = 0; i < data.length; i++) {\n\t\t\t_createRange(collectionId, data[i].rangeLength, data[i].price, data[i].tokensAllowed, data[i].lockedTokens, data[i].name);\n\t\t}\n\t}\n}"
    },
    "contracts/tokens/RAIR-721/Facets/RoyaltiesFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25;\n\nimport {ERC721Storage} from \"../AppStorage.sol\";\nimport {ERC721AccessControlRoles} from \"../AccessControlRoles.sol\";\nimport {AccessControlEnumerable} from \"../../../common/DiamondStorage/AccessControlEnumerable.sol\";\nimport {ERC2981} from \"@openzeppelin/contracts/token/common/ERC2981.sol\";\n\n/// @title  ERC2981 facet for RAIR diamond contracts\n/// @notice Functions needed for royalty standard\n/// @author Juan M. Sanchez M.\ncontract RAIRRoyaltiesFacet is ERC721AccessControlRoles, AccessControlEnumerable, ERC2981 {\n\t/// @notice Returns the fee for the NFT sale\n\t/// @param \ttokenId\t\tthe NFT asset queried for royalty information\n\t/// @param \tsalePrice\tthe sale price of the NFT asset specified by _tokenId\n\t/// @return address\t\taddress of who should be sent the royalty payment\n\t/// @return uint256\t\tthe royalty payment amount for _salePrice sale price\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view override returns (address, uint256) {\n\t\treturn (\n\t\t\tgetRoleMember(CREATOR, 0),\n\t\t\t(salePrice * ERC721Storage.layout().royaltyFee) / 100000\n\t\t);\n\t}\n\n\tfunction royaltyFee() external view returns(uint16) {\n\t\treturn ERC721Storage.layout().royaltyFee;\n\t}\n}"
    },
    "contracts/tokens/RAIR-721/RAIR-ERC721.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\n// Interfaces\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Metadata} from '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\nimport {IERC721Enumerable} from '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\nimport {ERC165} from '@openzeppelin/contracts/utils/introspection/ERC165.sol';\n\nimport {IDiamondLoupe} from \"../../diamondStandard/interfaces/IDiamondLoupe.sol\";\nimport {ERC721Storage} from \"./AppStorage.sol\";\nimport {ERC721AccessControlRoles} from \"./AccessControlRoles.sol\";\nimport {AccessControlEnumerable} from \"../../common/DiamondStorage/AccessControlEnumerable.sol\";\n\ninterface Factory {\n\tfunction getFacetSource() view external returns(address);\n}\n\n/// @title  RAIR ERC721 Diamond\n/// @dev \tFallback will get the facets from the factory\n/// @author Juan M. Sanchez M.\ncontract RAIR721_Diamond is ERC721AccessControlRoles, ERC165, AccessControlEnumerable {\n\t\n\tconstructor(\n        string memory name_,\n        string memory symbol,\n        address creatorAddress_,\n        uint16 creatorRoyalty_\n    ) {\n        ERC721Storage.Layout storage store = ERC721Storage.layout();\n\n\t\tstore._name = name_;\n\t\tstore._symbol = symbol;\n\n        store.requiresTrader = true;\n\t\tstore.factoryAddress = msg.sender;\n\n\t\tstore.royaltyFee = creatorRoyalty_;\n\t\t_setRoleAdmin(MINTER, CREATOR);\n\t\t_setRoleAdmin(TRADER, CREATOR);\n\t\t_grantRole(CREATOR, creatorAddress_);\n\t\t_grantRole(MINTER, creatorAddress_);\n\t\t_grantRole(TRADER, creatorAddress_);\n\t}\n\n\t/// @notice Returns the address from where the contract was created\n    /// @return factoryAddress Address of the factory\n\tfunction getFactoryAddress() public view returns (address factoryAddress) {\n        factoryAddress = ERC721Storage.layout().factoryAddress;\n\t}\n\n\t/// @notice This function allows us to know the URI of the contract \n    /// @return contractMetadataURI Contains the string with all the URI, this string is saved in memory \n\tfunction contractURI() public view returns (string memory contractMetadataURI) {\n        contractMetadataURI = ERC721Storage.layout().contractMetadataURI;\n\t}\n\n\t/// @notice This function allows us to know if and interface is suported\n\t/// @param \tinterfaceId Contains the facet addresses and function selectors\n\t/// @return bool contains the value for the interface, it could be true or false\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n        \tinterfaceId == type(IERC721Enumerable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n\tfallback() external {\n        Factory factory = Factory(ERC721Storage.layout().factoryAddress);\n\t\taddress facet = IDiamondLoupe(factory.getFacetSource()).facetAddress(msg.sig);\n\t\tassembly {\n\t\t\t// copy function selector and any arguments\n\t\t\tcalldatacopy(0, 0, calldatasize())\n\t\t\t// execute function call using the facet\n\t\t\tlet result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n\t\t\t// get any return value\n\t\t\treturndatacopy(0, 0, returndatasize())\n\t\t\t// return any return value or error back to the caller\n\t\t\tswitch result\n\t\t\t\tcase 0 {\n\t\t\t\t\trevert(0, returndatasize())\n\t\t\t\t}\n\t\t\t\tdefault {\n\t\t\t\t\treturn(0, returndatasize())\n\t\t\t\t}\n\t\t}\n\t}\n}"
    },
    "contracts/tokens/RAIR-ERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \nimport { ERC20Burnable } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract RAIR20 is ERC20, ERC20Burnable {\n    constructor(uint256 initialSupply, address recipient)\n        ERC20(\"RAIR\", \"RAIR\")\n    {\n        _mint(recipient, initialSupply);\n    }\n\n    receive() external payable {}\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}